## 2. Kotlin Basics / Основы языка Kotlin

- [2. Kotlin Basics / Основы языка Kotlin](#2-kotlin-basics--основы-языка-kotlin)
  - [Kotlin Syntax / Структура программы и базовый синтаксис](#kotlin-syntax--структура-программы-и-базовый-синтаксис)
    - [Main / Точка входа](#main--точка-входа)
    - [Main Parameters / Параметры функции `main`](#main-parameters--параметры-функции-main)
    - [Инструкции и блоки кода](#инструкции-и-блоки-кода)
    - [Определение имени пакета и импорт](#определение-имени-пакета-и-импорт)
  - [Kotlin Input/Output (Print Text) / Консольный ввод и вывод](#kotlin-inputoutput-print-text--консольный-ввод-и-вывод)
    - [Kotlin Output (Print) / Вывод в стандартный поток](#kotlin-output-print--вывод-в-стандартный-поток)
      - [The `println()` function / Функция `println()`](#the-println-function--функция-println)
      - [The `print()` function / Функция `print()`](#the-print-function--функция-print)
    - [Ввод с консоли](#ввод-с-консоли)
      - [Функция `readLine`](#функция-readline)
      - [Сравнение `readLine()`, `readln()`, `readlnOrNull()`](#сравнение-readline-readln-readlnornull)
  - [Kotlin Comments / Комментарии](#kotlin-comments--комментарии)
    - [Single-line Comments / Однострочные комментарии](#single-line-comments--однострочные-комментарии)
    - [Multi-line Comments / Многострочные комментарии](#multi-line-comments--многострочные-комментарии)
    - [Комментирование кода](#комментирование-кода)
  - [Kotlin Variables / Переменные](#kotlin-variables--переменные)
    - [Variables declaration / Объявление переменных](#variables-declaration--объявление-переменных)
    - [Изменяемые и неизменяемые переменные](#изменяемые-и-неизменяемые-переменные)
    - [Notes on `val` / По поводу `val`](#notes-on-val--по-поводу-val)
    - [Variable Type / Тип переменной](#variable-type--тип-переменной)
    - [Compile-time constants / Определение констант](#compile-time-constants--определение-констант)
    - [Display Variables / Вывод переменных](#display-variables--вывод-переменных)
    - [Variable Names / Именование переменных](#variable-names--именование-переменных)
  - [Kotlin Data Types / Типы данных](#kotlin-data-types--типы-данных)
    - [Data Types overview / Обзор типов данных](#data-types-overview--обзор-типов-данных)
    - [Numbers / Числа](#numbers--числа)
    - [Integer Types / Целочисленные типы](#integer-types--целочисленные-типы)
      - [`Byte`](#byte)
      - [`Short`](#short)
      - [`Int`](#int)
      - [`Long`](#long)
    - [Difference Between `Int` and `Long` / Отличие `Int` от `Long`](#difference-between-int-and-long--отличие-int-от-long)
    - [Floating Point Types / Числа с плавающей точкой](#floating-point-types--числа-с-плавающей-точкой)
      - [Scientific Numbers / Научная нотация](#scientific-numbers--научная-нотация)
    - [Booleans / Логический тип `Boolean`](#booleans--логический-тип-boolean)
      - [Boolean Values / Логические значения](#boolean-values--логические-значения)
      - [Boolean Expression / Логическое выражение](#boolean-expression--логическое-выражение)
    - [Characters / Символы](#characters--символы)
    - [Strings / Строки](#strings--строки)
      - [Kotlin Strings / О строках](#kotlin-strings--о-строках)
      - [Access a String / Доступ к элементам строки](#access-a-string--доступ-к-элементам-строки)
      - [String Length / Длина строки](#string-length--длина-строки)
      - [String Functions / Строковые функции](#string-functions--строковые-функции)
      - [Comparing Strings / Сравнение строк](#comparing-strings--сравнение-строк)
      - [Finding a String in a String / Поиск подстроки](#finding-a-string-in-a-string--поиск-подстроки)
      - [Quotes Inside a String / Кавычки внутри строк](#quotes-inside-a-string--кавычки-внутри-строк)
      - [String Concatenation / Конкатенация строк](#string-concatenation--конкатенация-строк)
      - [String Templates \& Interpolation / Шаблоны строк и интерполяция](#string-templates--interpolation--шаблоны-строк-и-интерполяция)
      - [Raw strings / Сырые строки](#raw-strings--сырые-строки)
    - [Arrays / Массивы](#arrays--массивы)
    - [Выведение типа](#выведение-типа)
    - [Статическая типизация](#статическая-типизация)
    - [Type Conversion / Преобразование типов](#type-conversion--преобразование-типов)
    - [Тип `Any`](#тип-any)
  - [Kotlin Operators / Операции](#kotlin-operators--операции)
    - [Kotlin Operators / Операторы](#kotlin-operators--операторы)
    - [Операции с числами](#операции-с-числами)
      - [Arithmetic Operators / Арифметические операции](#arithmetic-operators--арифметические-операции)
    - [Bitwise operators / Поразрядные операции](#bitwise-operators--поразрядные-операции)
    - [Kotlin Assignment Operators / Операции присвоения](#kotlin-assignment-operators--операции-присвоения)
    - [Условные выражения](#условные-выражения)
      - [Kotlin Comparison Operators / Операции отношения](#kotlin-comparison-operators--операции-отношения)
      - [Kotlin Logical Operators / Логические операции](#kotlin-logical-operators--логические-операции)
  - [Управляющие конструкции. Условия и циклы](#управляющие-конструкции-условия-и-циклы)
    - [Kotlin Conditions / Условия](#kotlin-conditions--условия)
    - [Kotlin If ... Else / Условная конструкция if...else](#kotlin-if--else--условная-конструкция-ifelse)
      - [Kotlin `if`](#kotlin-if)
      - [Kotlin `else`](#kotlin-else)
      - [Kotlin `else if`](#kotlin-else-if)
      - [Возвращение значения из `if`](#возвращение-значения-из-if)
    - [Kotlin If..Else Expressions / Условное выражение `if`](#kotlin-ifelse-expressions--условное-выражение-if)
    - [Kotlin When / Условная конструкция `when`](#kotlin-when--условная-конструкция-when)
      - [Выражение else](#выражение-else)
      - [Сравнение с набором значений](#сравнение-с-набором-значений)
      - [`when` и динамически вычисляемые значения](#when-и-динамически-вычисляемые-значения)
      - [`when` как альтернатива для `if..else`](#when-как-альтернатива-для-ifelse)
      - [Возвращение значения](#возвращение-значения)
    - [Kotlin `when` expression / Условное выражение `when`](#kotlin-when-expression--условное-выражение-when)
    - [Loops / Циклы](#loops--циклы)
      - [Kotlin While Loop / Цикл `while`](#kotlin-while-loop--цикл-while)
      - [The Do..While Loop / Цикл `do..while`](#the-dowhile-loop--цикл-dowhile)
      - [Сравнение `while` и `do..while`](#сравнение-while-и-dowhile)
      - [Kotlin For Loop / Цикл `for`](#kotlin-for-loop--цикл-for)
      - [Traditional For Loop / Традиционный цикл for](#traditional-for-loop--традиционный-цикл-for)
      - [Kotlin Break and Continue / Операторы `continue` и `break` в циклах](#kotlin-break-and-continue--операторы-continue-и-break-в-циклах)
        - [Kotlin Continue](#kotlin-continue)
        - [Kotlin Break](#kotlin-break)
  - [Flow Control / Управление потоком](#flow-control--управление-потоком)
    - [Операторы перехода](#операторы-перехода)
    - [Метки операторов break и continue](#метки-операторов-break-и-continue)
    - [Возврат к меткам](#возврат-к-меткам)

### Kotlin Syntax / Структура программы и базовый синтаксис

#### Main / Точка входа

Точкой входа в программу на языке Kotlin является функция **`main`**. Именно с этой функции начинается выполнение программы на Kotlin, поэтому эта функция должна быть в любой программе на языке Kotlin. Когда запускается программа на Kotlin, компилятор ищет функцию `main` и начинает выполнение кода с этой функции.

Функция `main` имеет следующий синтаксис:
```kotlin
fun main() {
    // код программы
}
```

Внутри функции `main` можно размещать код, который необходимо выполнить при запуске программы.

Главная цель функции `main` состоит в том, чтобы предоставить точку входа для выполнения программы. Это позволяет компилятору знать, с чего начинать выполнение кода и какую часть программы следует исполнять.

Таким образом, функция `main` является **обязательной** частью любой программы на Kotlin и обеспечивает структуру и порядок выполнения кода.

Можно создать файл Kotlin с названием *Main.kt* и следующим содержимым:
```kotlin
fun main() {
    println("Hello world!")
}
```

<details>
<summary><i>Вывод</i></summary>

```
Hello World
```

</details>

В качестве точки входа здесь определена функция `main`, выводящая надпись "Hello World" на экран.

Функция является блоком кода, предназначенного для выполнения определенной задачи. В примере выше в качестве такой функции определен объект `main()`.

Определение функции `main()` (в принципе как и других функций в Kotlin) начинается с ключевого слова **`fun`**. По сути оно указывает, что дальше идет определение функции. После `fun` указывается имя функции. В данном случае это **`main`**.

#### Main Parameters / Параметры функции `main`
После имени функции в скобках идет список параметров функции. Здесь функция `main` не принимает никаких параметров, поэтому после имени функции идут пустые скобки.

Стоит отметить, что до версии 1.3 в Kotlin функция `main` должна была принимать параметры — `fun main(args : Array<String>)`. Таким образом, чтобы приведенный выше пример заработал в старых версиях, его пришлось бы переписать следующим образом:

!!! example Пример
```kotlin
  fun main(args : Array<String>) {
  println("Hello World")
}
```

<details>
<summary><i>Вывод</i></summary>

```
Hello World
```

</details>

Параметр `args: Array<String>` здесь представляет массив строк `String`, через который в программу можно передать различные данные:
```kotlin
fun main(args: Array<String>) {
    println(args.contentToString())
}
```

**Примечание**: Начиная с версии 1.3 использовать такое определение функции с параметрами необязательно, и программа будет прекрасно работать без этого. Вместе с тем, прежняя форма не запрещена, и ничего страшного не случится, если, например, разработчик уже привык к такому синтаксису — при желании он может продолжать его использовать без всяких ограничений.

#### Инструкции и блоки кода

Вообще, функция `main()` — это то, что встречается в любой программе на Kotlin. Эта функция используется для **исполнения** кода. Все действия, которые выполняет функция (*инструкции*), заключаются в фигурные скобки. <dfn title="инструкция">Инструкции</dfn> (**statement**) являются основным строительным блоком программы на языке Kotlin. Каждая инструкция выполняет некоторое действие, например, вызовы функций, объявление переменных и присвоение им значений. Например:
```kotlin
println("Hello world!");
```

Эта строка представляет вызов встроенной функции `println()`, которая используется для вывода/печати текста. В данном случае она выводит на консоль некоторое сообщение — строку `"Hello world!"`.

Таким образом, единственное, что делает функция `main`, — вывод на консоль некоторого сообщения с помощью другой встроенной функции **`println()`**. Любой код внутри фигурных скобок `{}` функции `main()` будет выполнен. Следовательно, поскольку функция `println()` находится внутри функции `main()`, то она также будет выполнена.

> **Полезно знать**: Стоит отметить, что в Kotlin не обязательно ставить после инструкции точку запятой (`;`), как это часто требуется в других похожих языках программирования, таких как  Java, C++, C# и т.п. Каждая инструкция просто размещается на новой строке:
```kotlin
fun main(){
    println("Kotlin")
    println("Hello world!")
    println("Kotlin is a fun")
}
```

Тем не менее, если инструкции располагаются на одной строке, то чтобы их отделить друг от друга, надо указывать после инструкции точку с запятой:
```kotlin
fun main(){
    println("Kotlin");println("Hello world!");println("Kotlin is a fun")
}
```

#### Определение имени пакета и импорт
Имя пакета указывается в начале исходного файла, так же как и в Java.
```kotlin
package my.demo

import java.util.*

// ...
```

Но в отличие от Java, нет необходимости, чтобы структура пакетов совпадала со структурой папок: исходные файлы могут располагаться в произвольном месте на диске.

Подробнее см. [Пакеты](https://kotlinlang.ru/docs/packages.html).

### Kotlin Input/Output (Print Text) / Консольный ввод и вывод

#### Kotlin Output (Print) / Вывод в стандартный поток
Для вывода информации на консоль в Kotlin есть две встроенные функции:
```kotlin
print()
println()
```

Обе эти функции принимают некоторый объект, который надо вывести на консоль, обычно это строка. Различие между ними состоит в том, что функция `println()` при выводе на консоль добавляет перевод на новую строку:
```kotlin
fun main() {

    print("Hello ")
    print("Kotlin ")
    println()
    println("Kotlin is a fun")
}
```

Причем функция `println()` необязательно должна принимать некоторое значения. Так, здесь применяется пустой вызов функции, который просто делает перевод консольного вывода на новую строку:
```kotlin
println()
```

Консольный вывод программы:
```
Hello Kotlin on Metanit.com
Kotlin is a fun
```

Таким образом, `print` выводит свой аргумент в стандартный поток вывода.
```kotlin
print("Hello ")
print("world!")
```

А `println` выводит свой аргумент и добавляет перевод строки, так что следующее, что вы выведите, появится на следующей строке.
```kotlin
println("Hello world!")
println(42)
```

!!! example Пример
```kotlin
fun main() {
    val testF = "1234567"
    for (i in 0..testF.length - 1) {
        println(testF[i])
    }
    println("====================")
    for (i in 0..testF.length - 1) {
        print(testF[i])
    }
}

```

<details>
<summary><em>Вывод</em></summary>

```
1
2
3
4
5
6
7
====================
1234567

Process finished with exit code 0
```

</details>


!!! example Пример
```kotlin
fun main() {
    print("Введите трехзначное число: ")
    val testF = readln()
    println("==============")
    println("Простой вывод значения переменной")
    println(testF)
    println("Вывод переменной как части строки")
    println("Мы ввели число - $testF")
    println("Некорректное обращение к части строки")
    println("Первый символ введенного числа - $testF[0]")
    println("Обратите внимание на фигурные скобки")
    println("Первый символ введенного числа - ${testF[0]}")
}

```

<details>
<summary><em>Вывод</em></summary>

```
Введите трехзначное число: 987
==============
Простой вывод значения переменной
987
Вывод переменной как части строки
Мы ввели число - 987
Некорректное обращение к части строки
Первый символ введенного числа - 987[0]
Обратите внимание на фигурные скобки
Первый символ введенного числа - 9

Process finished with exit code 0
```

</details>

##### The `println()` function / Функция `println()`
Функция `println()` используется для вывода значений/печати текста:

!!! example Пример
```kotlin
fun main() {
  println("Hello World")
}
```

<details>
<summary><i>Вывод</i></summary>

```
Hello World
```

</details>

Можно добавлять столько функций `println()`, сколько необходимо. Стоит обратить внимание на, то при выводе каждая функция сделает перенос строки:

!!! example Пример
```kotlin
fun main() {
  println("Hello World!")
  println("I am learning Kotlin.")
  println("It is awesome!")
}
```

<details>
<summary><i>Вывод</i></summary>

```
Hello World!
I am learning Kotlin.
It is awesome!
```

</details>

С ее помощью можно также печатать числа и даже выполнять математические вычисления внутри:

!!! example Example
```kotlin
fun main() {
  println(3 + 3)
}
```

<details>
<summary><i>Вывод</i></summary>

```
6
```

</details>

##### The `print()` function / Функция `print()`
Также имеется функция `print()`, аналогичная `println()`, с тем лишь отличием что она не вставляет новую строку в конце вывода:

!!! example Пример
```kotlin
fun main() {
  print("Hello World! ")
  print("I am learning Kotlin. ")
  print("It is awesome!")
}
```

<details>
<summary><i>Вывод</i></summary>

```
Hello World! I am learning Kotlin. It is awesome!
```

</details>

> Можно обратить внимание на то, что для разделения фраз в конец каждого предложения добавлен символ пробела.

#### Ввод с консоли
В настоящее время стандартным способом чтения данных с консоли является использование функции `readln`:

!!! example Пример
```kotlin
fun main() {
    print("Введите строку символов: ")
    val testF = readln()
    println()

    for (i in 0..testF.length - 1) {
        print(testF[i])
    }
}
```

<details>
<summary><em>Вывод</em></summary>

```
Введите строку символов: Это строка символов

Это строка символов
Process finished with exit code 0

```

</details>

!!! example Пример
```kotlin
fun main() {
    print("Введите строку символов: ")
    val testF = readln()
    println()

    for (i in testF) {
        print(i)
    }
}

```

<details>
<summary><em>Вывод</em></summary>

```
Введите строку символов: Чтение символов из строки

Чтение символов из строки
Process finished with exit code 0

```

</details>

##### Функция `readLine`
Для ввода с консоли ранее широко применялась встроенная функция **`readLine()`**. Она возвращает введенную строку. Стоит отметить, что результат этой функции всегда представляет объект типа **`String`**. Соответственно введенную строку мы можем передать в переменную типа `String`:
```kotlin
fun main() {

    print("Введите имя: ")
    val name = readLine()

    println("Ваше имя: $name")
}
```

Здесь сначала выводится приглашение к вводу данных. Далее введенное значение передается в переменную `name`. Результат работы программы:
```
Введите имя: Евгений
Ваше имя: Евгений
```

Подобным образом можно вводить разные данные:
```kotlin
fun main() {

    print("Введите имя: ")
    val name = readLine()
    print("Введите email: ")
    val email = readLine()
    print("Введите адрес: ")
    val address = readLine()

    println("Ваше имя: $name")
    println("Ваш email: $email")
    println("Ваш адрес: $address")
}
```

Пример работы программы:
```
Введите имя: Евгений
Введите email: mail22@mail.ru
Введите адрес: ул. Кленов, д.31, кв. 20
Ваше имя: Евгений
Ваш email: mail22@mail.ru
Ваш адрес: ул. Кленов, д.31, кв. 20
```

##### Сравнение `readLine()`, `readln()`, `readlnOrNull()`
В Kotlin функции `readLine()` и `readln()` обе читают строку из стандартного ввода, но между ними есть важное отличие по поведению и типу возвращаемого значения:

- `readLine()` возвращает **nullable** `String?`. Если достигнут конец файла (EOF) или произошла ошибка ввода, то функция возвращает `null`. Это значит, что нужно проверять результат на `null`, чтобы избежать ошибок.

- `readln()` возвращает **не-nullable** `String`. Если при чтении возник конец файла (EOF), то `readln()` выбрасывает исключение `RuntimeException`. Это значит, что `readln()` гарантирует, что вернёт строку, либо прервёт программу исключением, если данных для чтения нет.

Другие нюансы:

- `readLine()` — это старая функция, существующая с ранних версий Kotlin, и она постепенно объявляется устаревшей (deprecated). В новых версиях рекомендуется использовать `readln()` или `readlnOrNull()` (возвращает `String?`), которые появились с Kotlin 1.6.0 и имеют более чёткую семантику.

- `readlnOrNull()` — альтернатива `readLine()` с той же логикой: возвращает `null` на EOF, но считается более современным и безопасным вариантом.

| Функция        | Возвращает | Действие при EOF или ошибке  | Рекомендуется использовать                  |
| -------------- | ---------- | ---------------------------- | ------------------------------------------- |
| **`readLine()`**     | `String?`    | Возвращает `null`              | Устаревает, лучше перейти на `readlnOrNull()` |
| **`readln()`**       | `String`     | Выбрасывает `RuntimeException` | Рекомендуется для гарантированного чтения   |
| **`readlnOrNull()`** | `String?`    | Возвращает `null`              | Современная альтернатива `readLine()`         |

Таким образом, если необходимо читать строку строго и не нужно обрабатывать `null`, используйте `readln()`. Если нужна возможность корректно обработать отсутствие ввода (EOF), следует использовать `readlnOrNull()`.

### Kotlin Comments / Комментарии

Код программы может содержать комментарии. Комментарии можно использовать для объяснения кода на Kotlin и для повышения его читаемости. Комментарии позволяют понять смысл программы, что делают те или иные ее части. Также с их помощью можно предотвратить выполнение кода при тестировании альтернативных вариантов. При компиляции комментарии игнорируются и не оказывают никакого влияния на работу приложения и на его размер.

В Kotlin есть два типа комментариев: однострочный и многострочный. Однострочный комментарий размещается на одной строке после двойного слеша `//`. А многострочный комментарий заключается между символами `/* текст комментария */`. Он может размещаться на нескольких строках. Например:
```kotlin
/*
    многострочный комментарий
    Функция main -
    точка входа в программу
*/
fun main(){                 // начало функции main

    println("Hello Kotlin") // вывод строки на консоль
}                           // конец функции main
```

#### Single-line Comments / Однострочные комментарии
Однострочные комментарии начинаются с двух прямых косых черт (`//`).

Любой текст, заключенный между `//` и концом строки, игнорируется Kotlin (т.е. не выполняется).

В примере ниже используется однострочный комментарий, помещенный перед строкой кода.

!!! example Пример
```kotlin
// This is a comment
println("Hello World")
```

<details>
<summary><i>Вывод</i></summary>

```
Hello World
```

</details>

А в данном примере используется однострочный комментарий, находящийся в конце строки кода:

!!! example Пример
```kotlin
println("Hello World")  // This is a comment
```

<details>
<summary><i>Вывод</i></summary>

```
Hello World
```

</details>

#### Multi-line Comments / Многострочные комментарии
Многострочные комментарии начинаются с `/*` и закончиваются `*/`.

Любой текст, заключенный между `/*` и `*/`, будет проигнорирован Kotlin.

В примере ниже многострочный комментарий (блок комментариев) используется для объяснения кода:

!!! example Пример
```kotlin
/* The code below will print the words Hello World
to the screen, and it is amazing */
println("Hello World")
```

<details>
<summary><i>Вывод</i></summary>

```
Hello World
```

</details>

#### Комментирование кода
Как упоминалось выше, комментарии — это способ добавить пояснения и объяснения к коду, чтобы его легче понять и поддерживать. Вместе с тем, комментарии также могут использоваться для временного отключения участков кода. Если заключить участок кода в комментарии, он не будет выполнен при запуске программы.
```kotlin
fun main() {
    // println("Этот код не будет выполнен")
    println("А этот будет")
}
```

### Kotlin Variables / Переменные

Для хранения данных в программе в Kotlin, как и в других языках программирования, применяются переменные. <dfn title="переменная">Переменная</dfn> представляет именованный участок памяти, который хранит некоторое значение.

Каждая переменная характеризуется определенным именем, типом данных и значением. Имя переменной представляет произвольный идентификатор, который может содержать алфавитно-цифровые символы или символ подчеркивания и должен начинаться либо с алфавитного символа, либо со знака подчеркивания. Для определения переменной можно использовать либо ключевое слово **`val`**, либо ключевое слово **`var`**.

Формальное определение переменной:
```kotlin
val|var имя_переменной: тип_переменной
```

Вначале идет слово **`val`** или **`var`**, затем имя переменной и через двоеточие тип переменной.

Например, определим переменную `age`:
```kotlin
var age: Int
```

То есть в данном случае объявлена переменная `age`, которая имеет тип **`Int`**. Тип `Int` говорит о том, что переменная будет содержать целочисленные значения.

После определения переменной ей можно присвоить значение:
```kotlin
fun main() {
    var age: Int
    age = 23
    println(age)
}
```

Для присвоения значения переменной используется знак равно. Затем мы можем производить с переменной различные операции. Например, в данном случае с помощью функции `println()` значение переменной выводится на консоль. И при запуске этой программы на консоль будет выведено число 23.

Присвоение значения переменной должно производиться только после ее объявления. И также мы можем сразу присвоить переменной начальное значение при ее объявлении. Такой прием называется <dfn title="инициализация">инициализацией</dfn>:
```kotlin
fun main() {
    var age: Int = 23
    println(age)
}
```

Однако обязательно надо присвоить переменной некоторое значение до ее использования:
```kotlin
fun main() {

    var age: Int
    println(age)// Ошибка, переменная не инициализирована
}
```

#### Variables declaration / Объявление переменных

Итак, переменные являются по сути контейнерами для хранения значений данных.

Для создания переменных необходимо использовать `var` или `val`, после чего переменной уже можно присвоить значение при помощи знака равенства (`=`):

!!! abstract Синтаксис
```kotlin
var variableName = value
val variableName = value
```

!!! example Пример
```kotlin
var name = "John"
val birthyear = 1975

println(name)          // Print the value of name
println(birthyear)     // Print the value of birthyear
```

<p>
<details>
<summary><i>Вывод</i></summary>

```
John
1975
```

</details>
</p>

#### Изменяемые и неизменяемые переменные
Выше было сказано, что переменные могут объявляться как с помощью слова **`val`**, так и с помощью слова **`var`**. В чем же разница между двумя этими способами?

Разница между `var` и `val` в том, что объявленные при помощи ключевого слова `var` переменные **могут быть изменены/модифицированы**, тогда как переменные `val` **не могут**.

С помощью ключевого слова **`val`** определяется <dfn title="неизменяемая переменная">неизменяемая переменная</dfn> (immutable variable) или <dfn title="переменная только для чтения">переменная только для чтения</dfn> (read-only).

```kotlin
val a: Int = 1   // Инициализация при объявлении
val b = 1        // Тип Int определен автоматически
val c: Int       // Указывать тип обязательно, если переменная не инициализирована сразу
c = 1            // Последующее присвоение
```


То есть присвоить значение такой переменной можно только один раз, но изменить его после первого присвоения уже нельзя. Например, в следующем случае мы получим ошибку:
```kotlin
fun main() {
    val age: Int
    age = 23        // здесь норм - первое присвоение
    age = 56        // здесь ошибка - переопределить значение переменной нельзя
    println(age)
}
```

А у переменной, которая определена с помощью ключевого слова **`var`** мы можем многократно менять значения (mutable variable):
```kotlin
fun main() {
    var age: Int
    age = 23
    println(age)
    age = 56
    println(age)
}
```

Таким образом, изменяемые переменные объявляются с помощью ключевого слова `var`.
```kotlin
var x = 5 // Тип Int определен автоматически
x += 1
```

Поэтому если не планируется изменять значение переменной в программе, то лучше определять ее с ключевым словом **`val`**.

!!! example Пример
```kotlin
fun main() {
    // Неизменяемые (только для чтения)
    // локальные переменные определяются
    // с помощью ключевого слова val.
    // Присвоить им значение можно только один раз.
    val testC = 7
    println(testC) // => 7

    // testC = 9 // => Kotlin: Val cannot be reassigned

    // Изменяемые переменные объявляются
    // с помощью ключевого слова var.
    var testD = "строка символов"
    println(testD) // => строка символов

    testD = "новая строка символов"
    println(testD) // => новая строка символов
}
```

<details>
<summary><em>Вывод</em></summary>

```
7
строка символов
новая строка символов

Process finished with exit code 0
```

</details>

!!! error Ошибка
```kotlin
testC = 9 // => Kotlin: Val cannot be reassigned
```

<details>
<summary>Вывод</summary>

```
Kotlin: Val cannot be reassigned

Process finished with exit code 0
```

</details>

Можно объявлять глобальные переменные:
```kotlin
val PI = 3.14
var x = 0

fun incrementX() {
    x += 1
}
```

#### Notes on `val` / По поводу `val`
Когда переменная создается при помощи ключевого слова `val`, ее значение **не может быть** изменено или повторно присвоено.

Следующий пример вызовет ошибку:

!!! error Пример
```kotlin
val name = "John"
name = "Robert"  // Error (Val cannot be reassigned)
println(name)
```

<p>
<details>
<summary><i>Вывод</i></summary>

```
prog.kt:3:3: error: val cannot be reassigned
  name = "Robert"
  ^
```

</details>
</p>

Использование `var` дает возможность изменять значение когда угодно:

!!! example Пример
```kotlin
var name = "John"
name = "Robert"
println(name)
```

<p>
<details>
<summary><i>Вывод</i></summary>

```
Robert
```

</details>
</p>

> Когда лучше всего использовать `val`?
>
> Ключевое слово `val` удобно, когда в переменной хранится неизменное значение, как, например, число "пи" (3.14159...):
>
> !!! example Пример
>
> ```kotlin
> val pi = 3.14159265359
> println(pi)
> ```
> <br>


#### Variable Type / Тип переменной
В отличие от множества других языков программирования, переменные в Kotlin не обязательно объявлять с указанием определенного *типа* (как, например, "String" для текстовых значений или "Int" для чисел).

Следующий пример демонстрирует создание переменных в Kotlin, одна из которых хранит текст, а другая — число:

!!! example Пример
```kotlin
var name = "John"      // String (text)
val birthyear = 1975   // Int (number)

println(name)          // Print the value of name
println(birthyear)     // Print the value of birthyear
```

<p>
<details>
<summary><i>Вывод</i></summary>

```
John
1975
```

</details>
</p>

Kotlin достаточно интеллектуален, чтобы разобраться в том, что **`"John"`** — это `String` (текстовая переменная), а **`1975`** — `Int` (числовое значение).

Тем не менее, при желании можно явно определить тип:

!!! example Пример
```kotlin
var name: String = "John" // String
val birthyear: Int = 1975 // Int

println(name)
println(birthyear)
```

<p>
<details>
<summary><i>Вывод</i></summary>

```
John
1975
```

</details>
</p>

Также можно определять переменную без присвоения значения, сделав это позже. **Однако** это возможно только при явном указании типа:

<table>
<thead>
  <tr>
    <th style="color: green">Рабочий вариант</th>
    <th style="color: red">Это вызовет ошибку</th>
  </tr>
<thead>
<tbody>
  <tr>
  <td>

  ```kotlin
  var name: String
  name = "John"
  println(name)
  ```

  </td>
  <td>

  ```kotlin
  var name
  name = "John"
  println(name)
  ```

  </td>
  </tr>
</tbody>
</table>

#### Compile-time constants / Определение констант
Также Kotlin поддерживает константы времени компиляции. Для их определения применяются ключевые слова **`const val`**:
```kotlin
const val maxAge = 120  // константа
fun main() {
    println(maxAge)
}
```

В данном случае `maxAge` является константой. Здесь `const val` — это свойство, значение которого известно на этапе компиляции и подставляется компилятором непосредственно в байткод. Грубо говоря, вместо обращения к переменной в итоговой программе используется буквально её значение, что оптимизирует работу.

Отличительной особенностью констант является то, что они на стадии **компиляции** должны иметь некоторое значение, и это значение изменить нельзя. Это накладывает на использование констант ряд ограничений:

- Естественно нельзя изменить значение константы:

  ```kotlin
  const val maxAge = 120  // константа
  fun main() {
      maxAge = 1500   // ошибка
      println(maxAge)
  }
  ```

  Здесь при попытке присвоения константе `maxAge` нового значения в функции `main` мы столкнемся с ошибкой на стадии компиляции. Если мы работаем в среде Intellij IDEA или Android Studio, то уже при написании кода на подобные ошибки укажет сама среда разработки.

- Константа должна объявляться на самом верхнем уровне (вне класса/функции):

  ```kotlin
  fun main() {
      const val maxAge = 120   // ошибка
      println(maxAge)
  }
  ```

- Тип данных константы должен соответствовать одному из примитивных (например, `Int`) или типу `String`.

- Инициализация допускается только простыми выражениями, результат которых известен на этапе компиляции (например, `2 * 2`, `"abc" + "def"`, но не результаты выполнения функций или обращения к переменным)

Также стоит отметит отличие **`val`**-переменных от констант (**`const val`**): значение `val`-переменных устанавливается во время выполнения, а значение констант — во время компиляции. Значение **`val`**-переменной также нельзя изменить после установки, однако мы можем объявить **`val`**-переменную, а потом дальше в программе присвоить ей значение. Константе же необходимо присвоить значение сразу при определении.

Преимущества констант времени компиляции:
- **Подстановка значения на этапе компиляции**: Устраняется накладная стоимость обращения к переменной — используется само значение прямо в месте использования. Это дает небольшое, но ощутимое преимущество по производительности при частом использовании.

- **Гарантированная неизменяемость**: Такие значения нельзя изменить уже после компиляции, что повышает читаемость и безопасность кода.

- **Использование в аннотациях**: Только `const val` можно передавать в аннотации (например, `@Deprecated(MY_CONSTANT)` или `@JvmField`), так как значение должно быть строго определено на этапе компиляции.

- **Упрощение повторного использования**: Значения, которые часто используются в разных частях приложения (например, строковые ключи, числовые пределы), удобно объявлять как compile-time constants для избежания дублирования и опечаток.

| | `const val`                  | `val`                                        |                                           |
| -------------------------- | ------------------------------------------ | ----------------------------------------- |
| Когда определяется         | На этапе компиляции                        | На этапе выполнения                       |
| Где объявлять              | Только top-level, object, companion object | В любом месте (локально, в классе и т.д.) |
| Какие типы                 | Только `String` и примитивы                  | Любые                                     |
| Эквивалентно               | `static final` в Java                        | `final`                                     |
| Использование в аннотациях | Да                                         | Нет                                       |
| Подстановка значения       | Да (inlined)                               | Нет                                       |

Когда использовать `const val`:
- Для "магических чисел", строк, ключей и других значений, которые известны никогда не изменятся и часто используются.

- В случаях, когда значение нужно использовать в аннотациях, где разрешаются только compile-time constants.

- Когда важен дополнительный контроль за неизменяемостью и хочется получить небольшой прирост производительности.

Пример:
```kotlin
const val API_URL = "https://api.example.com"
const val MAX_USERS = 100

object ErrorCodes {
    const val NOT_FOUND = 404
}
```

В отличие от этого, следующие объявления некорректны:
```kotlin
class MyClass {
    // Ошибка! const val нельзя объявлять в классе
    // const val SOME_VALUE = 10
}
```

Таким образом, `const val` полезны там, где требуется максимальная скорость и гарантированная неизменяемость, а также когда значения нужны для аннотаций или других compile-time инструментов. В других случаях, когда значения определяются только в процессе выполнения, лучше использовать `val`.

#### Display Variables / Вывод переменных
Как уже демонстрировалось в примерах выше, метод `println()` часто используется для вывода переменных.

Для объединения текста и значения переменной можно использовать символ `+`:

!!! example Пример
```kotlin
val name = "John"
println("Hello " + name)
```

<p>
<details>
<summary><i>Вывод</i></summary>

```
Hello John
```

</details>
</p>

Знак `+` можно использовать и для объединения самих переменных:

!!! example Пример
```kotlin
val firstName = "John "
val lastName = "Doe"
val fullName = firstName + lastName
println(fullName)
```

<p>
<details>
<summary><i>Вывод</i></summary>

```
John Doe
```

</details>
</p>

Для числовых значений символ `+` работает как знак математической операции:

!!! example Пример
```kotlin
val x = 5
val y = 6
println(x + y) // Print the value of x + y
```

<p>
<details>
<summary><i>Вывод</i></summary>

```
11
```

</details>
</p>

Пример выше демонстрирует следующее:

- `x` хранит значение `5`;
- `y` хранит значение `6`;
- после чего метод `println()` выводит результат операции `x + y`, равный **`11`**.

#### Variable Names / Именование переменных
Переменная может иметь короткое имя (как `x` и `y`) или же более описательное название (`age`, `sum`, `totalVolume`).

Переменные в Kotlin подчиняются следующим общим правилам именования:

- могут содержать буквы, цифры, подчеркивания и знаки доллара;
- в общем случае должны начинаться с буквы;
- при этом также могут начинаться с `$` и `_` (обычно используется в библиотеках);
- являются чувствительными к регистру ("myVar" и "myvar" являются разными переменными);
- как правило, должны начинаться со строчной буквы и не могут содержать пробельных символов;
- запрещено использовать зарезервированные слова (как, например, ключевые слова Kotlin вроде `var` или `String`).

> ##### Переменные в camelCase
>
> Как можно заметить, в примере выше в качестве имен были использованы **`firstName`** и **`lastName`**, а не `firstname` и `lastname`. Такой стиль написания назвается "верблюжьей нотацией" ("camelCase") и считается хорошей практикой, поскольку облегчает восприятие названий, составленных из разных слов, как, например, "myFavoriteFood", "rateActionMovies" и т.п.

### Kotlin Data Types / Типы данных

Поскольку в Kotlin используется статическая типизация, то все компоненты программы, в том числе переменные, представляют объекты, которые имеют определенный тип данных. Тип данных определяет, какой размер памяти может занимать объект данного типа и какие значения и операции с ним можно производить. В Kotlin есть несколько базовых типов данных: числа, символы, строки, логический тип и массивы.

#### Data Types overview / Обзор типов данных

В Kotlin тип переменной определяется ее значением:

!!! example Example
```kotlin
val myNum = 5             // Int
val myDoubleNum = 5.99    // Double
val myLetter = 'D'        // Char
val myBoolean = true      // Boolean
val myText = "Hello"      // String
```

Тем не менее, как это уже было указано в предыдущем разделе, можно явно определить целевой тип:

!!! example Example
```kotlin
val myNum: Int = 5                // Int
val myDoubleNum: Double = 5.99    // Double
val myLetter: Char = 'D'          // Char
val myBoolean: Boolean = true     // Boolean
val myText: String = "Hello"      // String
```

В одних случаях тип необходимо указывать, а в других этого делать не обязательно. В любом случае, не помешает знать, что из себя представляет тот или иной тип.

Более подробно о том, **когда тип указывать обязательно**, будет изложено далее.

Типы данных можно группировать следующим образом:

1. **_Базовые типы_**:
   - **Числовые** (Numeric):
     - Целочисленные (Integer): `(U)Byte`, `(U)Short`, `(U)Int`, `(U)Long`
     - Вещественные (Floating point): `Float`, `Double`
   - **Логические** (Boolean): `Boolean`
   - **Символьные** (Symbolic)
     - Символы (Characters): `Char`
     - Строки (Strings): `String`
2. **_Составные типы_**
   - **Кортежи** (Tuples): `Pair`, `Triple`
   - **Массивы** (Arrays): `Array`
   - **Коллекции** (Collections):
     - Списки (Lists): `List`, `MutableList`
     - Множества (Sets): `Set`, `HashSet`
     - Ассоциативные массивы (Maps): `Map`, `HashMap`

Основные базовые типы данных в Kotlin включают несколько групп:

1. Целочисленные типы:

   - `Byte` — 1 байт, значения от -128 до 127.

   - `Short` — 2 байта, значения от -32 768 до 32 767.

   - `Int` — 4 байта, значения от -2 147 483 648 до 2 147 483 647.

   - `Long` — 8 байт, очень большой диапазон от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807.

2. Вещественные (числа с плавающей точкой):

   - `Float` — 4 байта, меньшая точность.

   - `Double` — 8 байт, большая точность.

3. Символьный тип:

   - `Char` — хранит один символ (в одинарных кавычках).

4. Строковый тип:

   - `String` — последовательность символов в двойных кавычках.

5. Логический тип:

   - `Boolean` — может принимать только два значения: true или false.

Особенности Kotlin в работе с типами:

- Все типы в Kotlin — это объекты (ссылочные типы), нет примитивов как в Java.

- По умолчанию переменные не могут хранить `null`. Чтобы разрешить `null`, к типу добавляется `?,` например, `Int?`, `String?`.

- Переменные бывают изменяемыми (`var`) и неизменяемыми (`val`).

- Существуют знаковые (Signed) и беззнаковые (Unsigned) типы, у беззнаковых (`UByte`, `UInt` и т.д.) диапазон положительных значений вдвое больше.

Кроме базовых типов, есть составные: пары (`Pair`), тройки (`Triple`), массивы (`Array`), списки (`List`, `MutableList`), множества (`Set`, `HashSet`) и ассоциативные массивы (`Map`, `HashMap`).

Таким образом, Kotlin предлагает гибкую, строгую и одновременно безопасную систему типов для эффективной работы с данными.

В Kotlin нет типа `Object` в том виде, как он есть в Java. Вместо этого у всех классов в Kotlin есть общий суперкласс — `Any`. Он играет роль корня иерархии типов и является базовым классом для любого класса, если явно не указан другой суперкласс.

Класс `Any` содержит несколько стандартных методов, которые доступны всем объектам в Kotlin:

- `equals()`

- `hashCode()`

- `toString()`

Это значит, что любое значение или объект в Kotlin можно рассматривать как объект типа `Any`. Таким образом, `Any` — аналог `Object` в Java, но с некоторыми отличиями, например, отсутствием поддержки `null` (для этого используется отдельный тип `Any?`).

Кроме того, в Kotlin можно создавать объекты с помощью ключевого слова `object`. Такие объекты могут быть анонимными или с конкретными свойствами и методами. Это немного отличается от понятия класса, но тесно связано с объектно-ориентированной моделью в языке.

Итак, `Any` в Kotlin — это корневой суперкласс, который выполняет роль аналога `Object` в Java. Все классы наследуют от него по умолчанию, а если нужно, можно использовать анонимные объекты с `object` для единичных экземпляров

В Kotlin нет прямого аналога структур (struct), как в некоторых языках, например, в C или C#. Kotlin работает на базе JVM, и для подобных целей в нём обычно используются классы и особенно **data class** (классы данных).

Вот основные варианты замены структур в Kotlin:

- **Data class** — это лаконичный способ создать класс, который в первую очередь хранит данные. Kotlin автоматически создает методы `equals()`, `hashCode()`, `toString()`, а также функции копирования (`copy()`) для таких классов. Data class максимально близки по назначению к структурам данных в C# и C:
    ```kotlin
    data class User(val name: String, val age: Int)
    ```

- Обычные классы — если нужен более сложный функционал или контроль, можно использовать стандартные классы.

- Коллекции (Lists, Sets, Maps) — часто для хранения связанных данных используют структуры данных в виде коллекций Kotlin, которые встроены и активно используются в языке.

- **Value classes** (inline классы) — с Kotlin 1.5+ есть экспериментальная возможность определить value класс, который компилируется так, что не создает объект обертки и работает быстрее, приближаясь к структурам по производительности. Но они более ограничены по функционалу.

Таким образом, вместо структур в Kotlin принято использовать **data class** или **value class**, в зависимости от задачи. Если нужна лишь упаковка данных без логики — data class будет лучшим вариантом.

Это связано с тем, что Kotlin построен поверх Java, где нет user-defined примитивных структур (struct), поэтому нет и прямого аналога.

Если требуется более эффективное управление памятью и структурированные данные, можно рассмотреть value классы, но в большинстве случаях data class решает задачу удобного представления структурированных данных.

#### Numbers / Числа
Числовые типы можно разделить на две группы:

- <dfn title="Целочисленный тип">Целочисленные типы</dfn> (<dfn title="Integer type">Integer types</dfn>) хранят целые числа, положительные или отрицательные (как, например, 123 или -456), без десятичной части. Допустимыми типами являются `Byte`, `Short`, `Int` и `Long`.

- <dfn title="Тип с плавающей точкой">Типы с плавающей точкой</dfn> (<dfn title="Floating point type">Floating point types</dfn>) представляют собой числа с десятичной частью, содержащие хотя бы один значимый десятичный разряд. Имеет всего два таких типа: `Float` и `Double`.

> Если явно не указывать тип числовой переменно, то она, как правило, интерпретируется как `Int` для целых чисел и `Double` для чисел с плавающей точкой.

#### Integer Types / Целочисленные типы
- **`Byte`**: хранит целое число от -128 до 127 и занимает 1 байт

- **`Short`**: хранит целое число от -32 768 до 32 767 и занимает 2 байта

- **`Int`**: хранит целое число от -2 147 483 648 (-231) до 2 147 483 647 (231 - 1) и занимает 4 байта

- **`Long`**: хранит целое число от –9 223 372 036 854 775 808 (-263) до 9 223 372 036 854 775 807 (263-1) и занимает 8 байт

В последней версии Kotlin также добавлена поддержка для целочисленных типов без знака:

- **`UByte`**: хранит целое число от 0 до 255 и занимает 1 байт

- **`UShort`**: хранит целое число от 0 до 65 535 и занимает 2 байта

- **`UInt`**: хранит целое число от 0 до 232 - 1 и занимает 4 байта

- **`ULong`**: хранит целое число от 0 до 264-1 и занимает 8 байт

Объекты целочисленных типов хранят целые числа:
```kotlin
fun main(){

    val a: Byte = -10
    val b: Short = 45
    val c: Int = -250
    val d: Long = 30000
    println(a) // -10
    println(b) // 45
    println(c) // -250
    println(d) // 30000
}
```

По умолчанию все числовые литералы расцениваются как значения типа `Int`. При присвоении числовых литералов переменным других типов данных происходит неявное преобразование. Например:
```kotlin
fun main(){

    val a: Byte = 127  // 127 - значение типа Int преобразуется в тип Byte
    println(a) // 127
}
```

Здесь числовой литерал, который по умолчанию представляет тип `Int`, преобразуется к типу `Byte`. И в данном случае все нормально, так как 127 укладывается в диапазон значений типа `Byte`. Но возьмем другой пример:
```kotlin
fun main(){

    val a: Byte = 128  // Ошибка
    println(a) //
}
```

Здесь при присвоении числа 128 переменной типа `Byte` мы получим ошибку, поскольку число 128 вне диапазона значений для типа `Byte`.

Kotlin также поддерживает литералы типа `Long` — такие числовые литералы имеют суффикс **`L`**:
```kotlin
fun main(){

    val a: Long = 22    // 22 - Int, преобразование из Int в Long
    println(a) // 22
    val b: Long = 22L   // 22L - Long, преобразование не нужно
    println(b) // 22
}
```

Для передачи значений объектам, которые представляют беззнаковые целочисленные типы данных, после числа указывается суффикс **`U`**:
```kotlin
fun main(){

    val a: UByte = 10U
    val b: UShort = 45U
    val c: UInt = 250U
    val d: ULong = 30000U
    println(a) // 10
    println(b) // 45
    println(c) // 250
    println(d) // 30000
}
```

Кроме чисел в десятичной системе мы можем определять числа в двоичной и шестнадцатеричной системах.

Шестнадцатеричная запись числа начинается с **`0x`**, затем идет набор символов от 0 до F, которые представляют число:
```kotlin
val num: Int = 0x0A1    // 161
println(num) // 161
```

Двоичная запись числа предваряется символами **`0b`**, после которых идет последовательность из нулей и единиц:
```kotlin
val a: Int = 0b0101    // 5
val b: Int = 0b1011     // 11
println(a)      // 5
println(b)      // 11
```

Для упрощения работы с большими числами отдельные разряды чисел можно разделять с помощью прочерка:
```kotlin
fun main(){

    var million = 1_000_000
    var number = 1234_5678_9012_3456
    println(million)    // 1000000
    println(number)     // 1234567890123456
}
```

##### `Byte`
Тип данных `Byte` может хранить целые числа от -128 до 127. Его можно использовать вместо `Int` или любых других целочисленных типов для экономии памяти в том случае, когда значения гарантированно укладываются в диапазон от -128 до 127:

!!! example Example
```kotlin
val myNum: Byte = 100
println(myNum)
```

<details>
<summary><em>Output</em></summary>

```
100
```

</details>

##### `Short`
Тип данных `Short` может хранить целые числа в диапазоне от -32768 до 32767:

!!! example Example
```kotlin
val myNum: Short = 5000
println(myNum)
```

<details>
<summary><em>Output</em></summary>

```
5000
```

</details>

##### `Int`
Тип данных `Int` может хранить целые числа в диапазоне от -2147483648 до 2147483647:

!!! example Example
```kotlin
val myNum: Int = 100000
println(myNum)
```

<details>
<summary><em>Output</em></summary>

```
100000
```

</details>

##### `Long`
The `Long` data type can store whole numbers from -9223372036854775808 to 9223372036854775807. This is used when `Int` is not large enough to store the value. Optionally, you can end the value with an "L":

!!! example Example
```kotlin
val myNum: Long = 15000000000L
println(myNum)
```

<details>
<summary><em>Output</em></summary>

```
15000000000
```

</details>

#### Difference Between `Int` and `Long` / Отличие `Int` от `Long`
Целое число представляется типом `Int` до тех пор, пока оно не превышает  2147483647. При выходе за пределы этого значение оно интепретируется как  `Long`:

!!! example Example
```kotlin
val myNum1 = 2147483647  // Int
val myNum2 = 2147483648  // Long
```

#### Floating Point Types / Числа с плавающей точкой
Кроме целочисленных типов в Kotlin есть два типа для чисел с плавающей точкой, которые позволяют хранить дробные числа: `Float` и `Double`. Эти типы дают возможность представлять числа с десятичной частью, такие как 9.99 или 3.14515:

!!! example Float Example
```kotlin
val myNum: Float = 5.75F
println(myNum)
```

<details>
<summary><em>Output</em></summary>

```
5.75
```

</details>

!!! example Double Example
```kotlin
val myNum: Double = 19.99
println(myNum)
```

<details>
<summary><em>Output</em></summary>

```
19.99
```

</details>

- **`Float`**: хранит число с плавающей точкой от -3.4·10^38^ до 3.4·10^38^ и занимает 4 байта

- **`Double`**: хранит число с плавающей точкой от ±5.0·10^-324^ до ±1.7·10^308^ и занимает 8 байта.

В качестве разделителя целой и дробной части применяется точка:
```kotlin
val height: Double = 1.78
val pi: Float = 3.14F
println(height)      // 1.78
println(pi)         // 3.14
```

Чтобы присвоить число объекту типа `Float` после числа указывается суффикс `f` или `F`.

Также тип `Double` поддерживает экспоненциальную запись:
```kotlin
val d: Double = 23e3
println(d)      // 23 000

val g: Double = 23e-3
println(g)      // 0.023
```

> `Float` или `Double`?
>
> **Точность** (**precision**) значения с плавающей точкой указывает на то, сколько цифр может иметь значение после десятичной точки. Точность `Float` составляет лишь шесть или семь десятичных разрядов, тогда как переменные типа `Double` имеют точность около 15 разрядов. Так что для большинства вычислений безопаснее использовать `Double`.
>
> Кроме того, следует обратить внимание на то, что литерал типа `Float` должен оканчиваться символом "F".

##### Scientific Numbers / Научная нотация
Число с плавающей точкой может быть представлено в научной нотации (экспоненциальной записи) с использованием "e" или "E" для обозначения степени 10:

!!! example Example
```kotlin
val myNum1: Float = 35E3F
val myNum2: Double = 12E4
println(myNum1)
println(myNum2)
```

<details>
<summary><em>Output</em></summary>

```
35000.0
120000.0
```

</details>

#### Booleans / Логический тип `Boolean`

Очень часто в программировании требуется тип данных, позволяющий иметь только два значения, как:

- ДА / НЕТ
- ВКЛ. / ВЫКЛ.
- ИСТИНА / ЛОЖЬ

Для таких случаев в Kotlin предусмотрен специальный тип данных `Boolean`, способный принимать значенеия `true` или `false`.

##### Boolean Values / Логические значения
Тип `Boolean` может хранить одно из двух значений: `true` (истина) или `false` (ложь):
```kotlin
val a: Boolean = true
val b: Boolean = false
```

Логический тип может быть определен с помощью ключевого слова `Boolean`:

!!! example Example
```kotlin
val isKotlinFun: Boolean = true
val isFishTasty: Boolean = false
println(isKotlinFun)   // Outputs true
println(isFishTasty)   // Outputs false
```

<details>
<summary><em>Вывод</em></summary>

```
true
false
```

</details>

Аналогично другим типам данных, этот пример можно переписать без явного указания типа, поскольку Kotlin способен самостоятельно определить, что переменные имеют логический тип:

!!! example Пример
```kotlin
val isKotlinFun = true
val isFishTasty = false
println(isKotlinFun)   // Outputs true
println(isFishTasty)   // Outputs false
```

<details>
<summary><em>Вывод</em></summary>

```
true
false
```

</details>

Как следует из примеров выше, логические значения, как правило, используются для условных проверок.

##### Boolean Expression / Логическое выражение
Логическое выражение **возвращает** логическое значение: `true` или `false`.

Для того, чтобы определить, является ли выражение (или значение переменной) истинным, можно использовать оператор сравнения, как, например, **больше** (`>`):

!!! example Пример
```kotlin
val x = 10
val y = 9
println(x > y) // Возвращает true, поскольку 10 больше 9
```

<details>
<summary><em>Вывод</em></summary>

```
true
```

</details>

Или же еще проще:

!!! example Пример
```kotlin
println(10 > 9) // Возвращает true, поскольку 10 больше 9
```

<details>
<summary><em>Вывод</em></summary>

```
true
```

</details>

В примере ниже для оценки выражения используется оператор **равно** (`==`):

!!! example Пример
```kotlin
val x = 10;
println(x == 10); // Возвращает true, поскольку значение x равно 10
```

<details>
<summary><em>Вывод</em></summary>

```
true
```

</details>

!!! example Пример
```kotlin
println(10 == 15); // Возвращает false, поскольку 10 не равно 15
```

<details>
<summary><em>Вывод</em></summary>

```
false
```

</details>

> Логическое значение выражения является основой для всех сравнений и условий в Kotlin.

#### Characters / Символы
Символьные данные представлены типом `Char`, который используется для хранения **одиночного** символа:
```kotlin
val a: Char = 'A'
val b: Char = 'B'
val c: Char = 'T'
```

Значение данного типа выглядит как отдельный знак, который заключается в **одинарные** кавычки, как, например, `'A'` or `'c'`.

!!! example Example
```kotlin
val myGrade: Char = 'B'
println(myGrade)
```

<details>
<summary><em>Output</em></summary>

```
B
```

</details>

Также тип `Char` может представлять специальные последовательности, которые интерпретируются особым образом:

- `\t`: табуляция

- `\n`: перевод строки

- `\r`: возврат каретки

- `\'`: одинарная кавычка

- `\"`: двойная кавычка

- `\\`: обратный слеш

В отличие от Java, здесь нельзя использовать значения кодов ASCII для хранения и вывода соответствующих им символов. Например, литерал `66` будет отображен как "B" в Java, но в Kotlin это вызовет ошибку:

!!! error Example
```kotlin
val myLetter: Char = 66
println(myLetter) // Error
```

#### Strings / Строки
Строки представлены типом **`String`**:
```kotlin
fun main() {

    val name: String = "Eugene"

    println(name)
}
```

Строка представляет последовательность символов, заключенную в **двойные** кавычки, либо в тройные двойные кавычки.

!!! example Example
```kotlin
val myText: String = "Hello World"
println(myText)
```

<details>
<summary><em>Output</em></summary>

```
Hello World
```

</details>


Строка может содержать специальные символы или эскейп-последовательности. Например, если необходимо вставить в текст перевод на другую строку, можно использовать эскейп-последовательность `\n`:
```kotlin
val text: String = "SALT II was a series of talks between United States \n and Soviet negotiators from 1972 to 1979"
```

Для большего удобства при создании многострочного текста можно использовать тройные двойные кавычки:
```kotlin
fun main() {

    val text: String = """
                        SALT II was a series of talks between United States
                        and Soviet negotiators from 1972 to 1979.
                        It was a continuation of the SALT I talks.
                    """
    println(text)
}
```

##### Kotlin Strings / О строках
Строки используются для хранения текста

Строка представляет собой коллекцию символов, заключенных в двойные кавычки:

!!! example Example
```kotlin
var greeting = "Hello"
```

В отличие от Java, здесь не трубется явно указывать на то, что переменная должна быть типа `String`. Kotlin достаточно интеллектуален, чтобы определить тип приветственного сообщения в примере выше как `String` благодаря использованию двойных кавычек (по формату самого литерала).

Тем не менее, как и с любыми другими данными, при желании тип можно задать явно:

!!! example Example
```kotlin
var greeting: String = "Hello"
```

**Примечание**: Если необходимо создать `String` без присвоения значения (чтобы сделать это потом), то при объявлении переменной тип указывать обязательно:

<table>
<thead>
  <tr>
    <th style="color: green">Рабочий вариант</th>
    <th style="color: red">Это вызовет ошибку</th>
  </tr>
<thead>
<tbody>
  <tr>
  <td>

  ```kotlin
  var name: String
  name = "John"
  println(name)
  ```

<details>
<summary><em>Output</em></summary>

```
John
```

</details>

  </td>
  <td>

  ```kotlin
  var name
  name = "John"
  println(name)
  ```

<details>
<summary><em>Output</em></summary>

```
demo_variables4.kt:2:7: error: this variable must either have a type annotation or be initialized
  var name
      ^
```

</details>

  </td>
  </tr>
</tbody>
</table>

##### Access a String / Доступ к элементам строки
Доступ к символам (элементам) строки осуществляется по **номеру индекса** внутри **квадратных скобок**.

Индексы строк начинаются с 0. В примере ниже происходит обращение к первому и третьему элементам `txt`:

!!! example Example
```kotlin
var txt = "Hello World"
println(txt[0]) // first element (H)
println(txt[2]) // third element (l)
```

<details>
<summary><em>Output</em></summary>

```
H
1
```

</details>

> `[0]` является первым элементом, `[1]` — вторым, `[2]` — третьим и т.п.

##### String Length / Длина строки
Строка в Kotin представляет собой объект, содержащий свойства и некоторый функционал, позволяющий выполнять определенные операции над строками, доступные через точку (`.`), которая пишется после названия конкретной строковой переменной. Например, длина строки может быть найдена с помощью свойства `length` следующим образом:

!!! example Example
```kotlin
var txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
println("The length of the txt string is: " + txt.length)
```

<details>
<summary><em>Output</em></summary>

```
The length of the txt string is: 26
```

</details>

##### String Functions / Строковые функции
Существует достаточно большое количество функций, доступных для работы со строками, например, `toUpperCase()` и `toLowerCase()`:

!!! example Example
```kotlin
var txt = "Hello World"
println(txt.toUpperCase())   // Outputs "HELLO WORLD"
println(txt.toLowerCase())   // Outputs "hello world"
```

<details>
<summary><em>Output</em></summary>

```
HELLO WORLD
hello world
```

</details>

##### Comparing Strings / Сравнение строк
Функция `compareTo(`*`string`*`)` сравнивает две строки и возвращает 0, если они одинаковы:

!!! example Example
```kotlin
var txt1 = "Hello World"
var txt2 = "Hello World"
println(txt1.compareTo(txt2))  // Outputs 0 (they are equal)
```

<details>
<summary><em>Output</em></summary>

```
0
```

</details>

##### Finding a String in a String / Поиск подстроки
Функция `indexOf()` возвращает **индекс** (позицию) первого вхождения указанного текста в строке (включая пробельные символы):

!!! example Example
```kotlin
var txt = "Please locate where 'locate' occurs!"
println(txt.indexOf("locate"))  // Outputs 7
```

<details>
<summary><em>Output</em></summary>

```
7
```

</details>

> Важно помнить, что Kotlin считает позиции с нуля.<br>
> 0 — первая позиция в строке, 1 — вторая, 2 — третья...

##### Quotes Inside a String / Кавычки внутри строк
Если внутри строки нужны кавычки, то следует использовать одинарный вариант (`'`):

!!! example Example
```kotlin
var txt1 = "It's alright"
var txt2 = "That's great"
```

##### String Concatenation / Конкатенация строк
Оператор `+` можно использовать для создания новой строки путем соединения двух исходных строк (при этом знак плюса ставится между ними). Данная операция называется <dfn title="конкатенация">конкатенацией</dfn>:

!!! example Example
```kotlin
var firstName = "John"
var lastName = "Doe"
println(firstName + " " + lastName)
```

<details>
<summary><em>Output</em></summary>

```
John Doe
```

</details>

> Можно отметить, что при выводе на печать для разделения значений `firstName` и `lastName` добавлен фрагмент с пробелом (" ").

Для конкатенации строк также можно использовать функцию `plus()`:

!!! example Example
```kotlin
var firstName = "John "
var lastName = "Doe"
println(firstName.plus(lastName))
```

<details>
<summary><em>Output</em></summary>

```
John Doe
```

</details>

##### String Templates & Interpolation / Шаблоны строк и интерполяция
В качестве альтернативы конкатенации также можно использовать "шаблоны строк", предоставляющие удобный способ добавлять переменные и выражения внутри строки.

На переменную легко можно сослаться, просто используя символ `$`:

!!! example Example
```kotlin
var firstName = "John"
var lastName = "Doe"
println("My name is $firstName $lastName")
```

<details>
<summary><em>Output</em></summary>

```
My name is John Doe
```

</details>

Шаблоны строк (string templates) представляют удобный способ вставки в строку различных значений, в частности, значений переменных. Так, с помощью знака доллара `$` мы можем вводить в строку значения различных переменных:
```kotlin
fun main() {

    val firstName = "Tom"
    val lastName = "Smith"
    val welcome = "Hello, $firstName $lastName"
    println(welcome)    // Hello, Tom Smith
}
```

В данном случае вместо `$firstName` и `$lastName` будут вставляться значения этих переменных. При этом переменные необязательно должны представлять строковый тип:
```kotlin
val name = "Tom"
val age = 22
val userInfo = "Your name: $name  Your age: $age"
```

> "Шаблоны строк" являются весьма популярным функционалом языка Kotlin, поскольку они сокращают количество используемого кода. Например, в этом случае не требуется определять отдельного пробельного фрагмента между переменными `firstName` и `lastName`, как это было в примере с конкатенацией.

##### Raw strings / Сырые строки
Записывать многострочный текст без необходимости экранирования специальных символов, таких как обратная косая черта (`\`) и кавычки (`"`) в Kotlin можно с использованием сырового строкового литерала:
```kotlin
"""Here you can put a string with special symbols like '$' or
even print a string on
several lines"""
```

Это особый вид строк, которые заключаются не в обычные двойные кавычки `""`, а в тройные — тройные двойные кавычки `"""..."""`. Такие строки:

- Могут занимать несколько строк кода — то есть их можно писать в несколько строк без каких-то специальных символов.

- В них не нужно экранировать кавычки, обратные слэши и другие символы — они воспринимаются буквально.

- В них не работают управляющие последовательности, например, `\n` не будет переводом строки, он просто символ `\` и буква `n`.

- При этом можно делать подстановку переменных через `$переменная` или `${выражение}`, как и в обычных строках.

Пример raw string в Kotlin:
```kotlin
val text = """
    Это сырой
    многострочный
    текст с "кавычками" и \обратными\ слэшами,
    которые не нужно экранировать.
""".trimIndent()
```

Выведет:
```
Это сырой
многострочный
текст с "кавычками" и \обратными\ слэшами,
которые не нужно экранировать.
```

Часто в таких многострочных строках с отступами по коду получается лишний пробел. Для удаления отступов удобно использовать функции:

- `trimIndent()` — удаляет одинаковый отступ из всех строк.

- `trimMargin()` — удаляет отступы до символа-разделителя `|` (или другого, если указать).

Например:
```kotlin
val text = """
    |Первая строка
    |Вторая строка
    |Третья строка
""".trimMargin()
```

Выведет:
```
Первая строка
Вторая строка
Третья строка
```

Если нужно написать в сырой строке букву `$,` а не подстановку, используют конструкцию `${'$'}`:
```kotlin
val price = """Цена: ${'$'}100"""
println(price) // Выведет: Цена: $100
```

Таким образом, raw-строки — отличное средство для работы с многострочным текстом, SQL-запросами, JSON и другими структурами, где много кавычек, обратных слэшей и переносов строк.

#### Arrays / Массивы
Массивы используются для хранения множественных значений в одной переменной, что дает возможность не объявлять отдельные переменные для каждого значения. Массивы и коллекции подробно рассмотрены в [отдельном разделе](#kotlin-arrays--массивы).

#### Выведение типа
Kotlin позволяет выводить тип переменной на основании данных, которыми переменная инициализируется. Поэтому при инициализации переменной тип можно опустить:
```kotlin
val age = 5
```

В данном случае компилятор увидит, что переменной присваивается значение типа `Int`, поэтому переменная `age` будет представлять тип `Int`.

Соответственно если мы присваиваем переменной строку, то такая переменная будет иметь тип `String`.
```kotlin
val name = "Tom"
```

Любые целые числа, воспринимаются как данные типа **`Int`**.

Если же мы хотим явно указать, что число представляет значение типа `Long`, то следует использовать суффикс `L`:
```kotlin
val sum = 45L
```

Если надо указать, что объект представляет беззнаковый тип, то применяется суффикс **`u`** или **`U`**:
```kotlin
val sum = 45U
```

Аналогично все числа с плавающей точкой (которые содержат точку в качестве разделителя целой и дробной части) рассматриваются как числа типа `Double`:
```kotlin
val height = 1.78
```

Если мы хотим указать, что данные будут представлять тип `Float`, то необходимо использовать суффикс **`f`** или **`F`**:
```kotlin
val height = 1.78F
```

Однако нельзя сначала объявить переменную без указания типа, а потом где-то в программе присвоить ей какое-то значение:
```kotlin
val age     // Ошибка, переменная не инициализирована
age = 5
```

#### Статическая типизация
Тип данных ограничивает набор значений, которые мы можем присвоить переменной. Например, мы не можем присвоить переменной типа `Double` строку:
```kotlin
val height: Double = "1.78"
```

И после того, как тип переменной установлен, он не может быть изменен:
```kotlin
fun main() {

    var height: String = "1.78"
    height = 1.81       // !Ошибка - переменная height хранит только строки
    println(height)
}
```

Кроме того, мы не можем переменной одного типа напрямую присвоить значение переменной другого типа. Например:
```kotlin
fun main(){

    var longN: Long = 2
    var intN: Int = 4
    longN = intN   // ! Ошибка
    println(longN)
}
```

Здесь переменной типа `Long` мы пытаемся присвоить значение типа `Int`. В итоге мы получим ошибку. Казалось бы, значение переменной типа `Int` — число 4 вполне укладывается в диапазон значений типа `Long`. Более того саму переменную типа `Long` — `nLong` мы инициализируем значением типа `Int`. Тем не менее это разные типы, и мы получим ошибку.

В реальности мы можем решить эту проблему: Kotlin предоставляет нам ряд встроенных функций для преобразования данных к определенному типу:

- **`toByte`**

- **`toShort`**

- **`toInt`**

- **`toLong`**

- **`toFloat`**

- **`toDouble`**

- **`toChar`**

Так, мы можем изменить пример выше, применив функцию **`toLong`**:
```kotlin
fun main(){

    var longN: Long = 2
    var intN: Int = 4
    longN = intN.toLong()   // Ошибки нет
    println(longN)
}
```

#### Type Conversion / Преобразование типов
<dfn title="преобразование типов">Преобразование типов</dfn> — это процесс, при котором значение одного типа данных конвертируется в значение другого типа.

В Kotlin преобразование числовых типов отличается от Java. Например, с помощью следующего кода невозможно преобразовать тип `Int` в `Long`:

!!! error Example
```kotlin
val x: Int = 5
val y: Long = x
println(y) // Error: Type mismatch
```

<details>
<summary><em>Output</em></summary>

```
demo_type_conv.kt:3:17: error: type mismatch: inferred type is Int but Long was expected
  val y: Long = x
                ^
```

</details>

Для конвертации числового типа данных в другой тип необходимо использовать одну из следующих функций: `toByte()`, `toShort()`, `toInt()`, `toLong()`, `toFloat()`, `toDouble()` or `toChar()`:

!!! example Example
```kotlin
val x: Int = 5
val y: Long = x.toLong()
println(y)
```

<details>
<summary><em>Output</em></summary>

```
5
```

</details>

В Kotlin нет встроенной функции с названием `tryParse`, как в C#. Однако аналогичная по смыслу функциональность достигается с помощью безопасных методов парсинга, которые при ошибке возвращают `null` вместо выбрасывания исключения.

Основные варианты:

- Для числовых типов: существуют функции-расширения `toIntOrNull()`, `toDoubleOrNull()` и другие, которые пытаются преобразовать строку в число и возвращают `null` при неудаче. Это можно считать аналогом `TryParse` из C#:

    ```cs
    val number: Int? = "123".toIntOrNull() // 123
    val invalid: Int? = "abc".toIntOrNull() // null
    ```

- Есть также возможность создавать подобные функции самостоятельно, используя конструкцию `try { ... } catch { ... }` и возвращая `null` при ошибке.

- В стандартной библиотеке JVM (Java), на которой основан Kotlin, отсутствует точный аналог C#-метода `TryParse`, зато с Kotlin можно использовать именно такие функции `toXxxOrNull()`.

- Пример для чисел с таким подходом:

    ```cs
    val input = "3.14"
    val result = input.toDoubleOrNull()
    if (result != null) {
        println("Parsed: $result")
    } else {
        println("Invalid input")
    }
    ```

- Для более универсального парсинга (например, JSON, даты и др.) часто пишут функции с подобной логикой `tryOrNull { ... }`, где при исключении возвращается `null`.

**Вывод**: для парсинга в Kotlin можно использовать функции `toIntOrNull()`, `toDoubleOrNull()` и встроенный механизм `try-catch` с `null`, которые покрывают сценарий `TryParse` с безопасной проверкой. Основная идея — парсить с возвратом `null` вместо исключения, что именно делают функции-расширения Kotlin для числовых типов.

Вот простой пример использования `try` и `catch` в Kotlin для безопасного парсинга строки в число, который аналогичен поведению `tryParse` в других языках:
```cs
fun tryParseInt(str: String): Int? {
    return try {
        str.toInt() // пытаемся преобразовать строку в Int
    } catch (e: NumberFormatException) {
        null // если строка невалидна, возвращаем null вместо исключения
    }
}

fun main() {
    val validNumber = "123"
    val invalidNumber = "abc"

    println(tryParseInt(validNumber))   // Выведет: 123
    println(tryParseInt(invalidNumber)) // Выведет: null
}
```

Объяснение:

- В блоке `try` пытаемся выполнить код, который может выбросить исключение (toInt()).

- Если всё прошло успешно — возвращаем результат.

- Если возникло исключение `NumberFormatException` — ловим его в `catch` и возвращаем `null`.

Такой приём позволяет имитировать функцию `TryParse`, безопасно обрабатывать ошибочные данные и избегать сбоев программы.

#### Тип `Any`
В Kotlin также есть тип `Any`, который позволяет присвоить переменной данного типа любое значение:
```kotlin
fun main() {

    var name: Any = "Tom"
    println(name)   // Tom
    name = 6758
    println(name)   // 6758
}
```

### Kotlin Operators / Операции

В Kotlin существует широкий набор операций (операторов), которые можно разделить на несколько групп:

1. Арифметические операторы:

   - `+` (сложение)

   - `-` (вычитание)

   - `*` (умножение)

   - `/` (деление)

   - `%` (остаток от деления)

2. Операторы присваивания:

   - `=` (присваивание)

   - Расширенные операторы присваивания: `+=`, `-=`, `*=`, `/=`, `%=` (обновляют значение с операцией)

3. Инкремент и декремент:

   - `++` (увеличение на 1)

   - `--` (уменьшение на 1)

4. Логические операторы:

   - `&&` (логическое И)

   - `||` (логическое ИЛИ)

   - `!` (логическое НЕ)

5. Операторы сравнения:

   - `==` и `!=` (логическое равенство и неравенство, вызывают `equals()` для объектов)

   - `===` и `!==` (ссылочное равенство и неравенство)

   - `<`, `>`, `<=`, `>=` (операторы сравнения)

6. Управляющие конструкции:

   - `if-else` (условный оператор, возвращает значение)

   - `when` (аналог оператора `switch` в других языках)

7. Операторы для работы с `null`:

   - `?.` (безопасный вызов, если объект не `null`)

   - `?:` (оператор Элвис — возвращает значение слева, если не `null`, иначе справа)

   - `!!` (принудительное приведение к не `null`, с исключением, если значение `null`)

8. Побитовые операторы:

   - Для битовых операций (AND, OR, XOR и сдвигов) используются функции расширения, например: `shl()`, `shr()`, `and()`, `or()`.

Дополнительно можно перегружать операторы для своих классов с помощью ключевого слова `operator`. Это позволяет определять поведение операторов для пользовательских типов.

Таким образом, Kotlin предлагает привычный набор операторов, расширенный современными конструкциями для безопасности и удобства программирования

В Kotlin нет прямого синтаксиса с операторами `&`, `|`, `^`, как в некоторых других языках (например, Java или C++). Вместо этого побитовые операции реализуются с помощью функций-расширений, которые вызываются в инфиксной форме. Для целочисленных типов (`Int` и `Long`) доступны следующие побитовые операции:

- `and(bits)` — побитовое И (аналог `&`)

- `or(bits)` — побитовое ИЛИ (аналог `|`)

- `xor(bits)` — побитовое исключающее ИЛИ (аналог `^`)

- `inv()` — побитовое отрицание (аналог `~`)

- `shl(bits)` — сдвиг влево (`<<`)

- `shr(bits)` — сдвиг вправо с учётом знака (`>>`)

- `ushr(bits)` — сдвиг вправо без учёта знака (`>>>`)

Пример использования:
```kotlin
val x = 5  // 0101 в двоичном виде
val y = 3  // 0011 в двоичном виде

val resultAnd = x and y  // 1 (0001)
val resultOr = x or y    // 7 (0111)
val resultXor = x xor y  // 6 (0110)
```

Таким образом, в Kotlin вместо операторов `&`, `|`, `^` используются методы `and()`, `or()`, `xor()`, вызываемые как инфиксные функции.

#### Kotlin Operators / Операторы
Операторы (знаки операции) используются для выполнения операций с переменными и значениями.

Само значение при этом называют <dfn title="операнд">операндом</dfn> (<dfn title="operand">operand</dfn>), в то время как операция (действие, выполняемое над операндами) определяется <dfn title="оператор">оператором</dfn> (<dfn title="operator">operator</dfn>):

| Операнд   | Оператоор  | Операнд   |
| :-------: | :--------: | :-------: |
| `100`     | `+`        | `50`      |

В примере ниже числа `100` и `50` являются **операндами**, тогда как знак `+` называется **оператором**:

!!! example Example
```kotlin
var x = 100 + 50
```

Хотя оператор `+` часто используется для сложения двух значений, как в примере выше, он также может быть использован для сложения переменной и значения, или же двух переменных:

!!! example Example
```kotlin
var sum1 = 100 + 50       // 150 (100 + 50)
var sum2 = sum1 + 250     // 400 (150 + 250)
var sum3 = sum2 + sum2    // 800 (400 + 400)
```

Операторы Kotlin можно сгруппировать следующим образом:

- Арифметические операторы (Arithmetic operators)
- Операторы присвоения (Assignment operators)
- Операторы сравнения (Comparison operators)
- Логические операторы (Logical operators)

#### Операции с числами
Для операций с числами используются арифметические и поразрядные операторы.

##### Arithmetic Operators / Арифметические операции
Арифметические операторы используются для выполнения наиболее распространенных математических операций.

| Оператор   | Название       | Описание                         | Пример  |
| ---------- | -------------- | -------------------------------- | ------- |
| `+`        | Сложение (Addition)       | Складывает два значения | `x + y` |
| `-`        | Вычитание (Subtraction)    | Вычитает одно значение из другого | `x - y` |
| `*`        | Умножение (Multiplication) | Умножает два значения            | `x * y` |
| `/`        | Деление (Division)       | Делит одно значение на другое   | `x / y` |
| `%`        | Остаток (Modulus)        | Возвращает остаток от деления   | `x % y` |
| `++`       | Инкремент (Increment)      | Увеличивает значение на  1         | `++x`   |
| `--`       | Декремент (Decrement)      | Уменьшает значение на 1         | `--x`   |

Таким образом, Kotlin поддерживает базовые арифметические операции:

- **`+`** (сложение): возвращает сумму двух чисел.

    ```kotlin
    val x = 5
    val y = 6
    val z = x + y
    println(z)      // z = 11
    ```

- **`-`** (вычитание): возвращает разность двух чисел.

    ```kotlin
    val x = 5
    val y = 6
    val z = x - y  // z = -1
    ```

- **`*`** (умножение): возвращает произведение двух чисел.

    ```kotlin
    val x = 5
    val y = 6
    val z = x * y  // z = 30
    ```

- **`/`** (деление): возвращает частное двух чисел.

    ```kotlin
    val x = 60
    val y = 10
    val z = x / y  // z = 6
    ```

    При этом если в операции деления оба операнда представляют целые числа, то результатом тоже будет целое число, а если в процессе деления образовалась дробная часть, то она отбрасывается:
    ```kotlin
    fun main() {

        val x = 11
        val y = 5
        val z = x / y  // z =2
        println(z)// 2
    }
    ```

    Так в данном случае, хотя если согласно стандартной математике разделить 11 на 5, то получится 2.2. Однако поскольку оба операнда представляют целочисленный тип, а именно тип `Int`, то дробная часть — 0.2 — отбрасывается, поэтому результатом будет число 2, а переменная `z` будет представлять тип `Int`.

    Чтобы результатом было дробное число, один из операндов должен представлять число с плавающей точкой:
    ```kotlin
    fun main() {

        val x = 11
        val y = 5.0
        val z = x / y   // z =2.2
        println(z)      // 2.2
    }
    ```

    В данном случае переменная `y` представляет тип `Double`, поэтому результатом деления будет число 2.2, а переменная `z` также будет представлять тип `Double`.

- **`%`**: возвращает остаток от целочисленного деления двух чисел.

    ```kotlin
    val x = 65
    val y = 10
    val z = x % y  // z = 5
    ```

- **`++`** (инкремент): увеличивает значение на единицу.

    Префиксный инкремент возвращает увеличенное значение:
    ```kotlin
    var x = 5
    val y = ++x
    println(x)      // x = 6
    println(y)      // y = 6
    ```

    Постфиксный инкремент возвращает значение до увеличения на единицу:
    ```kotlin
    var x = 5
    val y = x++
    println(x)      // x = 6
    println(y)      // y = 5
    ```

- **`--`** (декремент): уменьшает значение на единицу.

    Префиксный декремент возвращает уменьшенное значение:
    ```kotlin
    var x = 5
    val y = --x
    println(x)      // x = 4
    println(y)      // y = 4
    ```

    Постфиксный декремент возвращает значение до уменьшения на единицу:
    ```kotlin
    var x = 5
    val y = x--
    println(x)      // x = 4
    println(y)      // y = 5
    ```

#### Bitwise operators / Поразрядные операции
Ряд операций выполняется над двоичными разрядами числа. Здесь важно понимать, как выглядит двоичное представление тех или иных чисел. В частности, число 4 в двоичном виде — 100, а число 15 — 1111.

Есть следующие поразрядные операторы (они применяются только к данным типов `Int` и `Long`):

- **`shl`**: сдвиг битов числа со знаком влево

    ```kotlin
    val z = 3 shl 2     // z = 11 << 2 = 1100
    println(z)          // z = 12
    val d = 0b11 shl 2
    println(d)          // d = 12
    ```

    В данном случае число сдвигается на два разряда влево, поэтому справа число в двоичном виде дополняется двумя нулями. То есть в двоичном виде 3 представляет 11. Сдвигаем на два разряда влево (дополняем справа двумя нулями) и получаем 1100, то есть в десятичной системе число 12.

- **`shr`**: сдвиг битов числа со знаком вправо

    ```kotlin
    val z = 12 shr 2     // z = 1100 >> 2 = 11
    println(z)          // z = 3
    val d = 0b1100 shr 2
    println(d)          // d = 3
    ```

    Число 12 сдвигается на два разряда вправо, то есть два числа справа фактически отбрасываем и получаем число 11, то есть 3 в десятичной системе.

- **`ushr`**: сдвиг битов беззнакового числа вправо

    ```kotlin
    val z = 12 ushr 2     // z = 1100 >> 2 = 11
    println(z)          // z = 3
    ```

- **`and`**: побитовая операция AND (логическое умножение или конъюнкция). Эта операция сравнивает соответствующие разряды двух чисел и возвращает единицу, если эти разряды обоих чисел равны 1. Иначе возвращает 0.

    ```kotlin
    val x = 5   // 101
    val y = 6   // 110
    val z = x and y     // z = 101 & 110 = 100
    println(z)          // z = 4

    val d = 0b101 and 0b110
    println(d)          // d = 4
    ```

- **`or`**: побитовая операция OR (логическое сложение или дизъюнкция). Эта операция сравнивает два соответствуюших разряда обоих чисел и возвращает 1, если хотя бы один разряд равен 1. Если оба разряда равны 0, то возвращается 0.

    ```kotlin
    val x = 5   // 101
    val y = 6   // 110
    val z = x or y     // z = 101 | 110 = 111
    println(z)         // z = 7

    val d = 0b101 or 0b110
    println(d)          // d = 7
    ```

- **`xor`**: побитовая операция XOR. Сравнивает два разряда и возвращает 1, если один из разрядов равен 1, а другой равен 0. Если оба разряда равны, то возвращается 0.

    ```kotlin
    val x = 5   // 101
    val y = 6   // 110
    val z = x xor y     // z = 101 ^ 110 = 011
    println(z)         // z = 3

    val d = 0b101 xor 0b110
    println(d)          // d = 3
    ```

- **`inv`**: логическое отрицание или инверсия — инвертирует биты числа.

    ```kotlin
    val b = 11  // 1011
    val c = b.inv()
    println(c)      // -12
    ```

#### Kotlin Assignment Operators / Операции присвоения
Операторы присвоения используются для установки (присваивания) переменным значений.

В примере ниже используются оператор **присвоения** (**assignment operator**: `=`) для установки значения **`10`** переменной с именем **`x`**:

!!! example Example
```kotlin
var x = 10
```

Также есть ряд операций присвоения, которые сочетают арифметические операции и присвоение:

- **`+=`**: присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: **`A += B`** эквивалентно **`A = A + B`**.

- **`-=`**: присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: **`A -= B`** эквивалентно **`A = A - B`**.

- **`*=`**: присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: **`A *= B`** эквивалентно **`A = A * B`**.

- **`/=`**: присваивание после деления. Присваивает левому операнду частное левого и правого операндов: **`A /= B`** эквивалентно **`A = A / B`**.

- **`%=`**: присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: **`A %= B`** эквивалентно **`A = A % B`**.

Например, оператор **присвоения сложением** (**addition assignment**: `+=`) добавляет значение к переменной:

!!! example Example
```kotlin
var x = 10
x += 5
```

| Оператор   | Пример    | Эквивалент  |
| ---------- | --------- | ----------- |
| `=`        | `x = 5`   | `x = 5`     |
| `+=`       | `x += 3`  | `x = x + 3` |
| `-=`       | `x -= 3`  | `x = x - 3` |
| `*=`       | `x *= 3`  | `x = x * 3` |
| `/=`       | `x /= 3`  | `x = x / 3` |
| `%=`       | `x %= 3`  | `x = x % 3` |

#### Условные выражения

Условные выражения представляют некоторое условие, которое возвращает значение типа `Boolean`: либо `true` (если условие истинно), либо `false` (если условие ложно).

##### Kotlin Comparison Operators / Операции отношения
Операторы сравнения используются для сравнения двух значений, возвращая значение типа `Boolean`: `true` или `false`.

| Оператор   | Название                 | Пример    |
| ---------- | ------------------------ | --------- |
| `==`       | Равно (Equal to)         | `x == y`  |
| `!=`       | Не равно (Not equal)     | `x != y`  |
| `>`        | Больше (Greater than)    | `x > y`   |
| `<`        | Меньше (Less than)       | `x < y`   |
| `>=`       | Больше или равно (Greater than or equal to) | `x >= y`  |
| `<=`       | Меньше или равно (Less than or equal to)    | `x <= y`  |

- **`>`** (больше чем): возвращает `true`, если первый операнд больше второго. Иначе возвращает `false`.

    ```kotlin
    val a = 11
    val b = 12
    val c : Boolean =  a > b
    println(c)      // false - a меньше чем b

    val d = 35 > 12
    println(d)      // true - 35 больше чем 12
    ```

- **`<`** (меньше чем): возвращает `true`, если первый операнд меньше второго. Иначе возвращает `false`.

    ```kotlin
    val a = 11
    val b = 12
    val c =  a < b   // true

    val d = 35 < 12  // false
    ```

- **`>=`** (больше чем или равно): возвращает `true`, если первый операнд больше или равен второму.

    ```kotlin
    val a = 11
    val b = 12
    val c = a >= b      // false
    val d = 11 >= a     // true
    ```

- **`<=`** (меньше чем или равно): возвращает `true`, если первый операнд меньше или равен второму.

    ```kotlin
    val a = 11
    val b = 12
    val c = a <= b      // true
    val d = 15 <= a     // false
    ```

- **`==`** (равно): возвращает `true`, если оба операнда равны. Иначе возвращает `false`.

    ```kotlin
    val a = 11
    val b = 12
    val c = a == b      // false
    val d = b == 12     // true
    ```

- **`!=`** (не равно): возвращает `true`, если оба операнда НЕ равны.

    ```kotlin
    val a = 11
    val b = 12
    val c = a != b      // true
    val d = b != 12     // false
    ```

##### Kotlin Logical Operators / Логические операции
Логические операторы используются для определения логических отношений на переменных или значениях:

| Оператор | Название    | Описание                                             | Пример            |
| -------- | ----------- | ------------------------------------------------------- | ------------------ |
| `&&`     | Логическое И (Logical and) | Возвращает `true`, если оба операнда истинны                | `x < 5 &&  x < 10` |
| `||`     | Логическое ИЛИ (Logical or)  | Возвращает `true`, если хотя бы один из операндов истинен           | `x < 5 || x < 4`   |
| `!`      | Логическое НЕ (Logical not) | Обращает результат, возвращает `false`, если результат истинен |                    |

Операндами в логических операциях являются два значения типа `Boolean`. Нередко логические операции объединяют несколько операций отношения:

- **`and`**: возвращает `true`, если оба операнда равны `true`.

    ```kotlin
    val a = true
    val b = false
    val c = a and b                    // false
    val d = (11 >= 5) and (9 < 10)     // true
    println(c)
    println(d)
    ```

- **`or`**: возвращает `true`, если хотя бы один из операндов равен `true`.

    ```kotlin
    val a = true
    val b = false
    val c = a or b                   // true
    val d = (11 < 5) or (9 > 10)     // false
    ```

- **`xor`**: возвращает `true`, если только один из операндов равен `true`. Если операнды равны, возвращается `false`.

    ```kotlin
    val a = true
    val b = false
    val c = a xor b                 // true
    val d = a xor (90 > 10)      // false
    ```

- **`!`**: возвращает `true`, если операнд равен `false`. И, наоборот, если операнд равен `true`, возвращается `false`.

    ```kotlin
    val a = true
    val b = !a  // false
    val c = !b  // true
    ```

    В качестве альтернативы оператору `!` можно использовать метод **`not()`**:

    ```kotlin
    val a = true
    val b = a.not()  // false
    val c = b.not()  // true
    ```

- **`in`**: возвращает `true`, если операнд имеется в некоторой последовательности.

    ```kotlin
    val a = 5
    val b = a in 1..6       // true - число 5 входит в последовательность от 1 до 6

    val c = 4
    val d = c in 11..15     // false - число 4 НЕ входит в последовательность от 11 до 15
    ```

Выражение `1..6` создает последовательность чисел от 1 до 6. И в данном случае оператор `in` проверяет, есть ли значение переменной `a` в этой последовательности. Поскольку значение переменной `a` имеется в данной последовательности, то возвращается `true`.

А выражение `11..15` создает последовательность чисел от 11 до 15. И поскольку значение переменной `с` в эту последовательность не входит, поэтому возвращается `false`.

Если нам, наоборот, хочется возвращать `true`, если числа **нет** в указанной последовательности, то можно применить комбинацию операторов **`!in`**:
```kotlin
val a = 8
val b = a !in 1..6      // true - число 8 не входит в последовательность от 1 до 6
```

### Управляющие конструкции. Условия и циклы
https://kotlinlang.ru/docs/control-flow.html

#### Kotlin Conditions / Условия
[66eeda0e5040133e8429e188](https://www.w3schools.com/kotlin/kotlin_conditions.php)

Условные конструкции позволяют направить выполнение программы по одному из путей в зависимости от условия.

Kotlin поддерживает стандартные логические условия из математики:

- Меньше: `a < b`
- Меньше или равно: `a <= b`
- Больше: `a > b`
- Больше или равно: `a >= b`
- Равно: `a == b`
- Не равно: `a != b`

Эти условия можно использовать для выполнения различных действий в зависимости от того или иного решения.

В Kotlin есть следующие условные конструкции:
- `if` используется для определения блока кода, исполняемого при истинности заданного условия;
- `else` используется для определения блока кода, исполняемого при ложности заданного условия;
- `else if` используется для определения нового условия для проверки, если первое условие ложно;
- `when` используется для определения множества альтернативных блоков кода для исполнения.

**Примечание**: В отличие от Java, `if..else` в Kotlin можно использовать как в виде **оператора** (**statement**), так и в качестве **выражения** **expression** (для присвоения значения переменной). Подробнее об этом изложено далее.

#### Kotlin If ... Else / Условная конструкция if...else
[66f115475040133e8429e1aa](https://metanit.com/kotlin/tutorial/2.6.php)

##### Kotlin `if`
Для определения блока кода, который должен быть выполнен, если условие истинно, используется `if`.

!!! abstract Синтаксис
```kotlin
if (condition) {
  // block of code to be executed if the condition is true
}
```

> Следует обратить внимание на то, что `if` пишется в нижнем регистре. Использование букв верхнего регистра (If или IF) вызовет ошибку.

В примере ниже просходит сравнение двух значений, чтобы выяснить, является ли 20 больше 18. Если условие истинно, то происходит печать определенного текста:

!!! example Пример
```kotlin
if (20 > 18) {
  println("20 is greater than 18")
}
```

<details>
<summary><em>Вывод</em></summary>

```
20 is greater than 18
```

</details>

Также можно сравнивать переменные:

!!! example Пример
```kotlin
val x = 20
val y = 18
if (x > y) {
  println("x is greater than y")
}
```

<details>
<summary><em>Вывод</em></summary>

```
x is greater than y
```

</details>


<details>
<summary><strong>Объяснение примера</strong></summary>

В примере выше используются две переменные, **`x`** и **`y`**, для того чтобы проверить, является ли `x` больше `y` (с помощью оператора `>`). Поскольку `x` равно 20, а `y` — 18, и известно, что 20 больше 18, то на экран выводится сообщение об этом ("x is greater than y").

</details>

Таким образом, конструкция `if` принимает условие, и если это условие истинно, то выполняется последующий блок инструкций.

```kotlin
val a = 10
if(a == 10) {

    println("a равно 10")
}
```

В данном случае в конструкции `if` проверяется истинность выражения `a == 10`, если оно истинно, то выполняется последующий блок кода в фигурных скобках, и на консоль выводится сообщение "a равно 10". Если же выражение ложно, тогда блок кода не выполняется.

##### Kotlin `else`
Для определения блока кода, который должен быть выполнен, если условие ложно, используется `else`.

!!! abstract Синтаксис
```kotlin
if (condition) {
  // block of code to be executed if the condition is true
} else {
  // block of code to be executed if the condition is false
}
```

!!! example Пример
```kotlin
val time = 20
if (time < 18) {
  println("Good day.")
} else {
  println("Good evening.")
}
// Outputs "Good evening."
```

<details>
<summary><em>Вывод</em></summary>

```
Good evening.
```

</details>

<details>
<summary><strong>Объяснение примера</strong></summary>

В примере выше `time` (20) больше 18, поэтому условие ложно, что вызывает переход к секции `else` и вывод на экран сообщения "Good evening". Если бы `time` было меньше 18, то программа бы напечатала "Good day".

</details>

Таким образом, если необходимо задать альтернативный вариант, то можно добавить блок **`else`**:
```kotlin
val a = 10
if(a == 10) {
    println("a равно 10")
}
else{
    println("a НЕ равно 10")
}
```

Соответственно, если условное выражение после оператора `if` истинно, то выполняется блок после `if`, если ложно — выполняется блок после `else`.

Если блок кода состоит из одного выражения, то в принципе фигурные скобки можно опустить:
```kotlin
val a = 10
if(a == 10)
    println("a равно 10")
else
    println("a НЕ равно 10")
```

##### Kotlin `else if`
Для определения нового условия в том случае, если первое является ложным, используется `else if`.

!!! abstract Синтаксис
```kotlin
if (condition1) {
  // block of code to be executed if condition1 is true
} else if (condition2) {
  // block of code to be executed if the condition1 is false and condition2 is true
} else {
  // block of code to be executed if the condition1 is false and condition2 is false
}
```

!!! example Example
```kotlin
val time = 22
if (time < 10) {
  println("Good morning.")
} else if (time < 20) {
  println("Good day.")
} else {
  println("Good evening.")
}
// Outputs "Good evening."
```

<details>
<summary><em>Вывод</em></summary>

```
Good evening.
```

</details>


<details>
<summary><strong>Объяснение примера</strong></summary>

В примере выше `time` (22) больше 10, поэтому **первое условие** ложно. Следующее условие, определенное в ветви `else if`, также является ложным, что вызывает переход к секции `else`, поскольку оба условия — **условие1** и **условие2** — являются ложным, поэтому на экран выводится сообщение "Good evening".

Однако, если бы `time` было равно 14, то программа бы напечатала "Good day."

</details>

Таким образом, если необходимо проверить несколько альтернативных вариантов, то можно добавить выражения **`else if`**:
```kotlin
val a = 10
if(a == 10) {
    println("a равно 10")
}
else if(a == 9){
    println("a равно 9")
}
else if(a == 8){
    println("a равно 8")
}
else{
    println("a имеет неопределенное значение")
}
```

##### Возвращение значения из `if`
Стоит отметить, что конструкция `if` может возвращать значение. Например, найдем максимальное из двух чисел:
```kotlin
val a = 10
val b = 20
val c = if (a > b) a else b

println(c)  // 20
```

Аналогично можно использовать **`else if`**:
```kotlin
val a = 20
val b = 20
val c = if (a > b) 1 else if (a < b) -1 else 0

println(c)  // 0
```

Если при определении возвращаемого значения надо выполнить еще какие-нибудь действия, то можно заключить эти действия в блоки кода:
```kotlin
val a = 10
val b = 20
val c = if (a > b){
    println("a = $a")
    a
} else {
    println("b = $b")
    b
}
```

В конце каждого блока указывается возвращаемое значение.

#### Kotlin If..Else Expressions / Условное выражение `if`
В языке Kotlin `if` является выражением, т.е. оно возвращает значение (которое можно присвоить переменной):

!!! example Пример
```kotlin
val time = 20
val greeting = if (time < 18) {
  "Good day."
} else {
  "Good evening."
}
println(greeting)
```

<details>
<summary><em>Вывод</em></summary>

```
Good evening.
```

</details>

Это позволяет отказаться от тернарного оператора (`условие ? условие истинно : условие ложно`), потому что обычному `if` вполне по силам его заменить.
```kotlin
// обычное использование
var max = a
if (a < b) max = b

// с блоком else
var max: Int
if (a > b) {
    max = a
} else {
    max = b
}

// в виде выражения
val max = if (a > b) a else b
```

**Примечание**: Как видно из примера выше, если `if` содержит только одну инструкцию, то фигурные скобки `{}` допустимо опускать:

!!! example Пример
```kotlin
fun main() {
  val time = 20
  val greeting = if (time < 18) "Good day." else "Good evening."
  println(greeting)
}
```

**Совет**: Данный пример демонстрирует использование сокращенного варианта `if...else` в качестве альтернативы т.н. "тернарному оператору" в Java.

Вместе с тем, “ветви” выражения `if` могут быть блоками, т.е. содержать несколько строк кода, при этом последнее выражение является значением блока:
```kotlin
val max = if (a > b) {
    print("возвращаем a")
    a
} else {
    print("возвращаем b")
    b
}
```

> Если `if` применяется в качестве выражения (например, возвращая его значение или присваивая его переменной), то использование ветки `else` является обязательным.

!!! example Example
```kotlin
fun main() {
    var testMax = 5
    val testNew = (0..9).random()
    println("testNew: $testNew")
    if (testMax < testNew) testMax = testNew
    println(testMax)

    val testOne = (10..19).random()
    val testTwo = (10..19).random()
    println("testOne: $testOne, testTwo: $testTwo")

    if (testOne > testTwo) {
        println(testOne)
    } else {
        println(testTwo)
    }

    val testPrint = if (testOne > testTwo) {
        print("Возвращаем testOne - ")
        testOne
    } else {
        print("Возвращаем testTwo - ")
        testTwo
    }

    println(testPrint)
}
```

<details>
<summary><em>Вывод</em></summary>

```
testNew: 7
7
testOne: 17, testTwo: 13
17
Возвращаем testOne - 17

Process finished with exit code 0

```

</details>

#### Kotlin When / Условная конструкция `when`
[66f3e4d45040133e8429e1ed](https://metanit.com/kotlin/tutorial/2.11.php)

Конструкция **`when`** проверяет значение некоторого объекта и в зависимости от его значения выполняет тот или иной код. Конструкция `when` аналогична конструкции `switch` в других языках. Формальное определение:
```kotlin
when(объект){

    значение1 -> действия1
    значение2 -> действия2

    значениеN -> действияN
}
```

Если значение объекта равно одному из значений в блоке кода `when`, то выполняются соответствующие действия, которые идут после оператора `->` после соответствующего значения.

Например:
```kotlin
fun main() {

    val isEnabled = true
    when(isEnabled){
        false -> println("isEnabled off")
        true -> println("isEnabled on")
    }
}
```

Здесь в качестве объекта в конструкцию `when` передается переменная `isEnabled`. Далее ее значение по порядку сравнивается со значениями в `false` и `true`. В данном случае переменная `isEnabled` равна `true`, поэтому будет выполняться код
```kotlin
println("isEnabled on")
```

##### Выражение else
В примере выше переменная `isEnabled` имела только два возможных варианта: `true` и `false`. Однако чаще бывают случаи, когда значения в блоке `when` не покрывают все возможные значения объекта. Дополнительное выражение `else` позволяет задать действия, которые выполняются, если объект не соответствует ни одному из значений. Например:
```kotlin
val a = 30
when(a){
    10 -> println("a = 10")
    20 -> println("a = 20")
    else -> println("неопределенное значение")
}
```

То есть в данном случае если переменная a равна `30`, поэтому она не соответствует ни одному из значений в блоке `when`. И соответственно будут выполняться инструкции из выражения `else`.

Если надо, чтобы при совпадении значений выполнялось несколько инструкций, то для каждого значения можно определить блок кода:
```kotlin
var a = 10
when(a){
    10 -> {
        println("a = 10")
        a *= 2
    }
    20 -> {
        println("a = 20")
        a *= 5
    }
    else -> { println("неопределенное значение")}
}
println(a)
```

##### Сравнение с набором значений
Можно определить одни и те же действия сразу для нескольких значений. В этом случае значения перечисляются через запятую:
```kotlin
val a = 10
when(a){
    10, 20 -> println("a = 10 или a = 20")
    else -> println("неопределенное значение")
}
```

Также можно сравнивать с целым диапазоном значений с помощью оператора **`in`**:
```kotlin
val a = 10
when(a){
    in 10..19 -> println("a в диапазоне от 10 до 19")
    in 20..29 -> println("a в диапазоне от 20 до 29")
    !in 10..20 -> println("a вне диапазона от 10 до 20")
    else -> println("неопределенное значение")
}
```

Если оператор **`in`** позволяет узнать, есть ли значение в определенном диапазоне, то связка операторов **`!in`** позволяет проверить отсутствие значения в определенной последовательности.

##### `when` и динамически вычисляемые значения
Выражение в `when` также может сравниваться с динамически вычисляемыми значениями:
```kotlin
fun main() {

    val a = 10
    val b = 5
    val c = 3
    when(a){
        b - c -> println("a = b - c")
        b + 5 -> println("a = b + 5")
        else -> println("неопределенное значение")
    }
}
```

Так, в данном случае значение переменной `a` сравнивается с результатом операций `b - c` и `b + 5`.

Кроме того, `when` также может может принимать динамически вычисляемый объект:
```kotlin
fun main() {

    val a = 10
    val b = 20
    when(a + b){
        10 -> println("a + b = 10")
        20 -> println("a + b = 20")
        30 -> println("a + b = 30")
        else -> println("Undefined")
    }
}
```

Можно даже определять переменные, которые будут доступны внутри блока `when`:
```kotlin
fun main() {

    val a = 10
    val b = 26
    when(val c = a + b){
        10 -> println("a + b = 10")
        20 -> println("a + b = 20")
        else -> println("c = $c")
    }
}
```

##### `when` как альтернатива для `if..else`
Причем в принципе нам необязательно вообще сравнивать значение какого-либо объекта. Конструкция `when` аналогично конструкции `if..else` просто может поверять набор условий и если одно из условий возвращает `true`, то выполнять соответствующий набор действий:
```kotlin
fun main() {

    val a = 15
    val b = 6
    when{
        (b > 10) -> println("b больше 10")
        (a > 10) -> println("a больше 10")
        else -> println("и a, и b меньше или равны 10")
    }
}
```

##### Возвращение значения
Как и `if` конструкция `when` может возвращать значение. Возвращаемое значение указывается после оператора `->`:
```kotlin
fun main(){
    val day = 2
    var dayOfweek = when (day) {
            1 -> "Monday"
            2 -> "Tuesday"
            3 -> "Wednesday"
            4 -> "Thursday"
            else -> "Unknown"
    }
    println(dayOfweek)      // Tuesday
}
```

Здесь в зависимости от значения переменной `day` в другой переменной — `dayOfweek` окажется та или иная строка.

Другой пример:
```kotlin
val sum = 1000

val rate = when(sum){
    in 100..999 -> 10
    in 1000..9999 -> 15
    else -> 20
}
println(rate)       // 15
```

Таким образом, если значение переменной `sum` располагается в определенном диапазоне, то возвращается то значение, которое идет после стрелки.

#### Kotlin `when` expression / Условное выражение `when`
[66eee6865040133e8429e1a0](https://www.w3schools.com/kotlin/kotlin_when.php)

Ключевое слово `when` определяет условное выражение с несколькими “ветвями” и таким образом способно заменить использование нескольких выражений `if..else`, что читается гораздо проще.

Оно используется для выбора одного из множества блоков кода, который будет выполнен:

!!! example Пример
Использовать порядковый номер дня недели для вывода названия дня:
```kotlin
val day = 4

val result = when (day) {
  1 -> "Monday"
  2 -> "Tuesday"
  3 -> "Wednesday"
  4 -> "Thursday"
  5 -> "Friday"
  6 -> "Saturday"
  7 -> "Sunday"
  else -> "Invalid day."
}
println(result)

// Outputs "Thursday" (day 4)
```

> В этом выражение `when` похоже на оператор `switch`, присутствующий в таких си-подобных языках, как Java.

Вот как оно работает:

- переменная `when` (**`day`**) вычисляется один раз;
- значение переменной **`day`** сравнивается со значениями каждой "ветви";
- каждая ветвь начинается со значения, за которым следует стрелка (`->`) и результат;
- если происходит совпадение, то выполняется соответствующий связанный блок кода;
- для определения кода, который выполняется при отсутствии совпадения, используется `else`;
- в примере выше значение `day` равно `4`, поэтому будет выведено "Thursday".

Таким образом, `when` последовательно сравнивает свой аргумент со всеми указанными значениями, пока не выполнится какое-либо из условий ветвей.

```kotlin
when (x) {
    1 -> print("x == 1")
    2 -> print("x == 2")
    else -> { // обратите внимание на блок
        print("x не равен ни 1, ни 2")
    }
}
```

Интересно, что `when` можно использовать и как выражение, и как оператор. При использовании его в виде выражения значение первой ветки, удовлетворяющей условию, становится значением всего выражения. При использовании в виде оператора значения отдельных веток отбрасываются. В точности как `if`: каждая ветвь может быть блоком и её значением является значение последнего выражения блока.

Значение ветки `else` вычисляется в том случае, когда ни одно из условий в других ветках не удовлетворено.

Если `when` используется как *выражение*, то ветка `else` является обязательной, за исключением случаев, в которых компилятор может убедиться, что ветки покрывают все возможные значения. Так происходит, например с записями [класса `enum`](https://kotlinlang.ru/docs/enum-classes.html) и с подтипами [`sealed` (изолированных) классов](https://kotlinlang.ru/docs/sealed-classes.html).
```kotlin
enum class Bit {
  ZERO, ONE
}
val numericValue = when (getRandomBit()) {
    Bit.ZERO -> 0
    Bit.ONE -> 1
    // 'else' не требуется, потому что все случаи учтены
}
```

В *операторах* `when` ветка `else` является обязательной в следующих условиях:

- `when` имеет объект типа `Boolean`, `enum`, `sealed` или их nullable-аналоги;
- ветки `when` не охватывают все возможные случаи для этого объекта.

```kotlin
enum class Color {
    RED, GREEN, BLUE
}

when (getColor()) {
    Color.RED -> println("red")
    Color.GREEN -> println("green")
    Color.BLUE -> println("blue")
    // 'else' не требуется, потому что все случаи учтены
}

when (getColor()) {
    Color.RED -> println("red") // нет веток для GREEN и BLUE
    else -> println("not red") // 'else' обязателен
}
```

Если для нескольких значений выполняется одно и то же действие, то условия можно перечислять в одной ветке через запятую.
```kotlin
when (x) {
    0, 1 -> print("x == 0 or x == 1")
    else -> print("otherwise")
}
```

Помимо констант в ветках можно использовать произвольные выражения.
```kotlin
when (x) {
    s.toInt() -> print("s encodes x")
    else -> print("s does not encode x")
}
```

Также можно проверять вхождение аргумента в [интервал](#диапазоны-и-прогрессии) `in` или `!in` или его наличие в коллекции:
```kotlin
when (x) {
    in 1..10 -> print("x is in the range")
    in validNumbers -> print("x is valid")
    !in 10..20 -> print("x is outside the range")
    else -> print("none of the above")
}
```

Помимо этого Kotlin позволяет с помощью `is` или `!is` проверить тип аргумента. Обратите внимание, что благодаря [умным приведениям](https://kotlinlang.ru/docs/typecasts.html#smart-casts) можно получить доступ к методам и свойствам типа без дополнительной проверки.
```kotlin
fun hasPrefix(x: Any) = when(x) {
    is String -> x.startsWith("prefix")
    else -> false
}
```

`when` удобно использовать вместо цепочки условий вида `if`-`else if`. При отсутствии аргумента условия работают как простые логические выражения, а тело ветки выполняется при его истинности.
```kotlin
when {
    x.isOdd() -> print("x is odd")
    y.isEven() -> print("y is even")
    else -> print("x+y is odd")
}
```

Можно получать переменную внутри `when` условия по следующему синтаксису:
```kotlin
fun Request.getBody() =
    when (val response = executeRequest()) {
        is Success -> response.body
        is HttpError -> throw HttpException(response.status)
    }
```

Такая переменная, объявленная внутри условия `when` может быть видна только внутри тела этого `when`.

!!! example Пример
```kotlin
fun main() {
    val testRandom = (1..9).random()
    println("testRandom: $testRandom")
    when (testRandom) {
        1 -> println("testRandom == 1")
        2, 4, 6, 8 -> println("testRandom == 2 или 4 или 6 или 8")
        else -> { // обратите внимание на блок
            println("testRandom не равен 1 и не кратно 2")
        }
    }
    val testArrayInt = IntArray(10) { it }
    val testRandomNew = (1..30).random()
    println("testRandomNew: $testRandomNew")
    when (testRandomNew) {
        in 10..20 -> println("Значение в промежутке от 10 до 20")
        in testArrayInt -> println("Значение попадает в массив с числами от 0 до 9")
        !in 21..25 -> println("Значение больше 25")
        else -> println("Значение в промежутке от 21 до 25")
    }
    val testRem = when(testRandomNew) {
        in 1..15 -> testRandomNew
        else -> "Значение больше 15"
    }
    println(testRem)
}
```

<details>
<summary><em>Вывод</em></summary>

```
testRandom: 6
testRandom == 2 или 4 или 6 или 8
testRandomNew: 4
Значение попадает в массив с числами от 0 до 9
4

Process finished with exit code 0

```

</details>

#### Loops / Циклы

<dfn title="цикл">Циклы</dfn> представляют вид управляющих конструкций, которые позволяют в зависимости от определенных условий выполнять некоторое действие множество раз. Другими словами, циклы исполняют блок кода до тех пор, пока выполняется заданное условие. 

Циклы удобны тем, что экономят время, уменьшают количество ошибок и делают код более читаемым.

##### Kotlin While Loop / Цикл `while`

Цикл `while` повторяет определенные действия пока истинно некоторое условие:

!!! abstract Синтаксис
```kotlin
while (condition) {
  // code block to be executed
}
```

В примере ниже код цикла будет выполняться повторно до тех пор, пока переменная счетчика (`i`) остается меньше 5:

!!! example Пример
```kotlin
var i = 0
while (i < 5) {
  println(i)
  i++
}
```

<details>
<summary><i>Вывод</i></summary>

```
0
1
2
3
4
```

</details>

> **Примечание**: Не следует забывать увеличивать значение переменной в условии, иначе цикл станет бесконечным.

В следующем примере пока переменная `i` больше 0, будет выполняться цикл, в котором на консоль будет выводиться квадрат значения `i`:

```kotlin
var i = 10
while(i > 0){
    println(i*i)
    i--;
}
```

В данном случае вначале проверяется условие `(i > 0)` и если оно истинно (то есть возвращает `true`), то выполняется цикл. И вполне может быть ситуация, когда к началу выполнения цикла условие не будет выполняться. Например, переменная `i` изначально меньше 0, тогда цикл вообще не будет выполняться.

##### The Do..While Loop / Цикл `do..while`
Цикл `do..while` является разновидностью цикла `while`. Данный цикл однократно выполнит блок кода перед тем, как проверить истинность условия, после чего будет повторять цикл до тех пор, пока условие остается истинным.

!!! abstract Синтаксис
```kotlin
do {
  // code block to be executed
}
while (condition);
```

Пример ниже демонстрирует использование цикла `do/while`. Этот цикл будет выполнен в любом случае как минимум один раз, даже если условие ложно, поскольку блок кода выполняется до проверки условия:

!!! example Пример
```kotlin
var i = 0
do {
  println(i)
  i++
  }
while (i < 5)
```

<details>
<summary><i>Вывод</i></summary>

```
0
1
2
3
4
```

</details>

> Не стоит забывать увеличивать значение переменной счетчика, иначе цикл никогда не прекратит выполнение!

Таким образом, `do..while` является другой формой цикла `while`:
```kotlin
var i = -1
do{
    println(i*i)
    i--;
}
while(i > 0)
```

В данном случае вначале выполняется блок кода после ключевого слова **`do`**, а потом оценивается условие после `while`. Если условие истинно, то повторяется выполнение блока после `do`. То есть несмотря на то, что в данном случае переменная `i` меньше 0 и она не соответствует условию, тем не менее блок `do` выполнится хотя бы один раз.

##### Сравнение `while` и `do..while`
Тело циклов `while` и `do-while` выполняется до тех пор, пока их условие выполняется. Разница между ними заключается во времени проверки условия:

- `while` проверяет условие и, если оно истинно, выполняет тело, а затем возвращается к проверке условия;
- `do-while` выполняет тело и только затем проверяет условие. Если оно выполняется, цикл повторяется. Таким образом, тело `do-while` выполняется по крайней мере один раз независимо от условия.
```kotlin
while (x > 0) {
    x--
}

do {
    val y = retrieveData()
} while (y != null) // y здесь доступно!
```

!!! example Пример
```kotlin
fun main() {
    val testSize = (1..10).random()
    var testArr = IntArray(testSize)

    var i = 0
    while (i < testSize) {
        testArr[i] = (20..50).random()
        i++
    }
    testArr.forEach { print(it.toString() + "\t") }
    println()
    var j = 0
    do {
        testArr[j] = (20..50).random()
        j++
    } while (j < testSize)
    testArr.forEach { print(it.toString() + "\t") }
}
```

<details>
<summary><em>Вывод</em></summary>

```
21	40	40	28
45	21	50	48
Process finished with exit code 0

```

</details>

##### Kotlin For Loop / Цикл `for`
Очень часто при работе с массивами приходися пробегать по всем элементам.

Для перебора элементов массива обычно используется цикл `for` в сочетании с оператором `in`:

Его формальный синтаксис выглядит следующим образом:
```kotlin
for(переменная in последовательность){
    выполняемые инструкции
}
```

Таким образом, телом цикла может быть блок кода:
```kotlin
for (item: Int in ints) {
    // ...
}
```

!!! example Пример

*Вывести все элементы в массиве `cars`*:
```kotlin
val cars = arrayOf("Volvo", "BMW", "Ford", "Mazda")
for (x in cars) {
  println(x)
}
```

<details>
<summary><i>Вывод</i></summary>

```
Volvo
BMW
Ford
Mazda
```

</details>

Перебирать можно любые виды массивов. В примере выше фигурировал массив строк.

Пример ниже демонстрирует обход массива целых чисел:

!!! example Пример

```kotlin
val nums = arrayOf(1, 5, 10, 15, 20)
for (x in nums) {
  println(x)
}
```

<details>
<summary><i>Вывод</i></summary>

```
1
5
10
15
20
```

</details>

Вообще, цикл **`for`** обеспечивает перебор всех значений, поставляемых итератором (что позволяет обходить не только массивы, но и, например, коллекции):
```kotlin
for (item in collection) print(item)
```

Здесь цикл **`for`** пробегается по всем элементам коллекции. В этом плане цикл **`for`** в Kotlin эквивалентен циклу `for-each` в ряде других языков программирования (таких как, например, C#).

Как отмечено выше, цикл `for` позволяет проходить по всем элементам объекта, имеющего итератор, например:

- обладающего внутренней или внешней функцией `iterator()`, возвращаемый тип которой `Iterator<>`:
  - обладает внутренней или внешней функцией `next()`
  - обладает внутренней или внешней функцией `hasNext()`, возвращающей `Boolean`.

Все три указанные функции должны быть объявлены как `operator`.

Чтобы перебрать диапазон чисел, можно использовать выражение диапазона:
```kotlin
for (i in 1..3) {
    println(i)
}
for (i in 6 downTo 0 step 2) {
    println(i)
}
```

Цикл `for` по диапазону или массиву компилируется в основанный на индексе цикл, который не создает объект итератора.

Например, выведем все квадраты чисел от 1 до 9, используя цикл `for`:
```kotlin
for(n in 1..9){
    print("${n * n} \t")
}
```

В данном случае перебирается последовательность чисел от 1 до 9. При каждом проходе цикла (итерации цикла) из этой последовательности будет извлекаться элемент и помещаться в переменную `n`. И через переменную `n` можно манипулировать значением элемента. То есть в данном случае мы получим следующий консольный вывод:
```
1 	4 	9 	16 	25 	36 	49 	64 	81
```

Если при проходе по массиву или списку необходим порядковый номер элемента, можно использовать следующий подход:
```kotlin
for (i in array.indices) {
    println(array[i])
}
```

Также можно использовать библиотечную функцию `withIndex`.
```kotlin
for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
}
```

!!! example Пример
```kotlin
fun main() {
    val testArrayInt = IntArray(5) { it * 5 }

    for (item in testArrayInt) print(item.toString() + "\t")
    println()
    for (item in testArrayInt) {
        if (item % 3 == 0) {
            print("кратно\t")
        } else {
            print("некратно\t")
        }
    }
    println()
    for ((index, value) in testArrayInt.withIndex()) {
        println("Индекс - $index. Значение - $value")
    }
}
```

<details>
<summary><em>Вывод</em></summary>

```
0	5	10	15	20
кратно	некратно	некратно	кратно	некратно
Индекс - 0. Значение - 0
Индекс - 1. Значение - 5
Индекс - 2. Значение - 10
Индекс - 3. Значение - 15
Индекс - 4. Значение - 20

Process finished with exit code 0
```

</details>

Циклы могут быть вложенными. Например, выведем таблицу умножения:
```kotlin
for(i in 1..9){
    for(j in 1..9){
        print("${i * j} \t")
    }
    println()
}
```

В итоге на консоль будет выведена следующая таблица умножения:
```
1 	2 	3 	4 	5 	6 	7 	8 	9
2 	4 	6 	8 	10 	12 	14 	16 	18
3 	6 	9 	12 	15 	18 	21 	24 	27
4 	8 	12 	16 	20 	24 	28 	32 	36
5 	10 	15 	20 	25 	30 	35 	40 	45
6 	12 	18 	24 	30 	36 	42 	48 	54
7 	14 	21 	28 	35 	42 	49 	56 	63
8 	16 	24 	32 	40 	48 	56 	64 	72
9 	18 	27 	36 	45 	54 	63 	72 	81
```

##### Traditional For Loop / Традиционный цикл for
В отличие от Java и других языков программирования, Kotlin не предоставляет традиционного цикла `for`.

В Kotlin цикл `for` предназначен для перебора массивов, диапазонов и прочих структур, содержащих исчислимое количество значений. Подробнее обо всех этих структурах будет изложено отдельно ниже.

В Kotlin нет традиционного цикла for в том виде, как в Java (с инициализацией счетчика, условием и инкрементом), потому что язык ориентирован на более удобный и безопасный синтаксис для перебора коллекций, массивов и диапазонов. В Kotlin цикл `for` используется для итерации по объектам, которые предоставляют итератор, например, по массивам или диапазонам, что обеспечивает более читаемый и выразительный код без необходимости вручную управлять индексами и условиями завершения цикла.

Это сделано для упрощения и уменьшения ошибок (например, путаницы с условиями `<=` или `<` в классическом цикле), а также для повышения производительности, так как в байт-коде Kotlin итерация иногда оптимизируется до классического цикла с индексами. Так, Kotlin предлагает более высокоуровневый и декларативный подход к циклам, который в целом выигрывает в удобстве и безопасности по сравнению с традиционным циклом `for` из Java.

Синтаксис `for-in` в Kotlin дает ряд преимуществ по сравнению с классическим `for` в Java:

- **Лаконичность и читаемость**: В Kotlin цикл `for-in` позволяет перебрать коллекции, массивы и диапазоны без необходимости явно управлять индексами, условиями и инкрементами, что сокращает количество шаблонного кода и делает код проще и компактнее. В Java классический цикл `for` требует явного объявления переменной-счетчика, условия цикла и шага итерации, что занимает больше строк и увеличивает вероятность ошибок.

- **Безопасность и удобство**: Цикл `for-in` в Kotlin работает с итерируемыми объектами, что исключает риски неправильного управления индексами и выхода за границы массива. Это повышает надежность кода по сравнению с классическим `for`, где такие ошибки распространены.

- **Оптимизация и производительность**: Несмотря на более высокий уровень абстракции, Kotlin при компиляции часто оптимизирует цикл `for-in` в эффективные низкоуровневые конструкции, что позволяет избежать значительных потерь производительности по сравнению с классическим `for` в Java.

- **Выделение намерений**: Синтаксис `for-in` лучше раскрывает смысл итерации — перебор конкретных элементов коллекции — а не управление счетчиком, что улучшает читаемость и сопровождение кода.

Таким образом, синтаксис `for-in` в Kotlin обеспечивает более современный, компактный и безопасный способ итерации по коллекциям и диапазонам по сравнению с традиционным циклом `for` в Java, облегчая разработку и снижая вероятность ошибок. Соответственно, в Kotlin нет именно традиционного цикла `for` в классическом виде, потому что язык проектировался с акцентом на улучшение опыта разработки и использование идиоматичных средств перебора коллекций и других итерируемых структур.

##### Kotlin Break and Continue / Операторы `continue` и `break` в циклах

###### Kotlin Continue
Иногда при использовании цикла возникает необходимость при некоторых условиях не дожидаться выполнения всех инструкций в цикле, перейти к новой итерации. Для этого можно использовать оператор **`continue`**:

```kotlin
for(n in 1..8){
    if(n == 5) continue;
    println(n * n)
}
```

В данном случае когда `n` будет равно 5, сработает оператор `continue`. И последующая инструкция, которая выводит на консоль квадрат числа, не будет выполняться. Цикл перейдет к обработке следующего элемента в массиве

Таким образом, оператор `continue` прерывает одну (текущую) итерацию цикла, если выполняется указанное условие, и переходит к следующей итерации данного цикла.

В данном примере цикл пропускает значение 4:

!!! example Пример

```kotlin
var i = 0
while (i < 10) {
  if (i == 4) {
    i++
    continue
  }
  println(i)
  i++
}
```

<details>
<summary><i>Вывод</i></summary>

```
0
1
2
3
5
6
7
8
9
```

</details>

###### Kotlin Break
Бывает, что при некоторых условиях нам вовсе надо выйти из цикла, прекратить его выполнение. В этом случае применяется оператор **`break`**:

```kotlin
for(n in 1..5){
    if(n == 5) break;
    println(n * n)
}
```

В данном случае когда `n` окажется равен 5, то с помощью оператора `break` будет выполнен выход из цикла. Цикл полностью завершится.

Таким образом, оператор `break` используется для выхода из **цикла**.

В данном примере происходит выход из цикла, когда `i` становится равным 4:

!!! example Пример

```kotlin
var i = 0
while (i < 10) {
  println(i)
  i++
  if (i == 4) {
    break
  }
}
```

<details>
<summary><i>Вывод</i></summary>

```
0
1
2
3
```

</details>

Однако следует помнить, что оператор **`break`** выводит только из текущего цикла, где он вызывается. Например, возьмем следующую конструкцию с внешним и внутренним циклами:

```kotlin
fun main() {

    for(i in 1..3){
        for(j in 1..3){
            if(j == 3) break;
            println("Hello")
        }
    }
}
```

Сколько раз здесь будет выведена строка "Hello"? Очевидно 6 раз.

```
Hello
Hello
Hello
Hello
Hello
Hello
```

Каждый раз во внутреннем цикле `j` окажется равна 3, произойдет переход к новой итерации внешнего цикла по `i`. Но что если нам надо вообще выйти из всех циклов, в том числе и из внешнего? Наиболее простым в данном случае способом будет использование меток:

```kotlin
fun main() {

    outerloop@ for(i in 1..3){
        for(j in 1..3){
            if(j == 3) break@outerloop;
            println("Hello")
        }
    }
}
```

В данном случае внешний цикл маркирован меткой `outerloop`. Название метки произвольное, единственное, что завершается символом `@`. И кода во внутреннем цикле будет выполняться условие `j == 3` оператор **`break`** выйдет из цикла, предваряемого меткой `outerloop`.

```kotlin
if(j == 3) break@outerloop;
```

Таким образом, Kotlin поддерживает привычные операторы `break` и `continue` в циклах. Подробнее об их использовании изложено в разделе [Операторы перехода](#операторы-перехода).

### Flow Control / Управление потоком
В Kotlin есть уникальная возможность использования меток (labels) для операторов перехода (`break`, `continue`, `return`), которые позволяют управлять выходом из вложенных циклов или функций. Метки имеют вид идентификатора с символом `@,` например, `loop@`, и служат для уточнения, из какого именно блока нужно выйти или продолжить выполнение.

В Java прямого аналога таким меткам, как в Kotlin, нет. В Java управление переходами ограничено простыми операторами `break` и `continue`, которые управляют только ближайшими циклами без возможности указать конкретную метку. Для возвращения из вложенных конструкций с более точным управлением обычно приходится использовать дополнительные логические переменные, методы или исключения.

В C# нет прямого эквивалента меткам, как в Kotlin, которые можно использовать с операторами `break`, `continue` и `return` для выхода из конкретно помеченного блока.

Однако C# поддерживает операторы перехода:

- `break` — выходит из ближайшего внешнего цикла или оператора `switch`.

- `continue` — пропускает текущую итерацию цикла и переходит к следующей.

- `return` — завершает выполнение метода и возвращает результат (если он есть).

Для более сложного управления потоком, аналогичного меткам Kotlin, в C# можно использовать оператор `goto` с метками, расположенными внутри того же метода. Метки в C# выглядят как идентификаторы с двоеточием и позволяют переходить к определённому месту кода, но это считается менее структурированным и часто не рекомендуется к использованию из-за ухудшения читаемости кода.

**Итого**:

- Kotlin позволяет использовать метки с оператором `break`, `continue` и `return` для точного управления потоком выполнения.

- Java не имеет встроенных меток, подобно Kotlin; оператор `break` может принимать метки только для именованных циклов (цикл с меткой), но эта возможность гораздо ограниченнее и в практическом плане используется редко.

- в C# нет нативного механизма меток как у Kotlin для операторов `break`, `continue` и `return`, но можно использовать `goto` для помеченных переходов в пределах метода. В то же время прямое управление потоком через метки с `break`, `continue` и `return` в C# не предусмотрено, в отличие от Kotlin, где это встроенный и широко используемый механизм.

Таким образом, метки в Kotlin — это более развитый и гибкий механизм управления переходами, который в традиционном Java отсутствует или реализован иначе (через именованные циклы, но без общего механизма меток, как в Kotlin).

#### Операторы перехода

В Kotlin определено три оператора перехода:

- `return` по умолчанию производит возврат из ближайшей окружающей его функции или анонимной функции;
- `break` завершает выполнение ближайшего окружающего его цикла;
- `continue` продолжает выполнение цикла со следующего его шага, без обработки оставшегося кода текущей итерации.

Все эти выражения можно использовать как часть более крупных выражений:
```kotlin
val s = person.name ?: return
```

Эти выражения имеют тип `Nothing`.

#### Метки операторов break и continue
Любое выражение в Kotlin может быть помечено меткой *label*. Метки имеют форму идентификатора, за которым следует знак `@`, например `abc@` или `fooBar@`. Для того чтобы пометить выражение, мы просто ставим метку перед ним.
```kotlin
loop@ for (i in 1..100) {
    // ...
}
```

Теперь мы можем уточнить значения операторов `break` или `continue` с помощью меток.
```kotlin
loop@ for (i in 1..100) {
    for (j in 1..100) {
        if (...) break@loop
    }
}
```

Оператор `break`, отмеченный `@loop`, переводит выполнение кода в точку сразу после цикла, отмеченного этой меткой. Оператор `continue` продолжает цикл со следующей его итерации.

#### Возврат к меткам
В Kotlin функции могут быть вложены друг в друга с помощью литералов функций, локальных функций и анонимных объектов. Подходящий `return` позволит вернуться из внешней функции. Одним из самых важных применений этой синтаксической конструкции является возврат из лямбда-выражения. Напомним, что в таких случаях, как в примере ниже, `return` возвращает из ближайшей заключающей функции — `foo`:
```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return // нелокальный возврат, непосредственно к объекту вызывающему функцию foo()
        print(it)
    }
    println("эта строка не достижима")
}
```

Обратите внимание, что такой нелокальный возврат поддерживается только лямбда-выражениями, переданными [инлайн-функциям](https://kotlinlang.ru/docs/inline-functions.html). Чтобы вернуться из лямбда-выражения, к оператору стоит поставить метку и тем самым сделать уточнение для `return`.
```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach lit@{
        if (it == 3) return@lit // локальный возврат внутри лямбды, то есть к циклу forEach
        print(it)
    }
    print(" выполнится с использованием явной метки(lit@)")
}
```

Теперь он возвращает только из лямбда-выражения. Зачастую намного более удобно использовать *неявные метки*, потому что такие метки имеют такое же имя, как и функция, к которой относится лямбда.
```kotlin
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return@forEach // локальный возврат внутри лямбды, то есть к циклу forEach
        print(it)
    }
    print(" выполнится с использованием неявной метки(forEach@)")
}
```

Возможно также использование [анонимной функции](https://kotlinlang.ru/docs/lambdas.html#anonymous-functions) в качестве альтернативы лямбда-выражениям. Оператор `return` возвращает из самой анонимной функции.

```
fun foo() {
    listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {
        if (value == 3) return  // локальный возврат внутри анонимной функции, то есть к циклу forEach
        print(value)
    })
    print(" выполнится с использованием анонимной функции")
}
```

Обратите внимание, что использование локальных возвратов в предыдущих трех примерах аналогично использованию `continue` в обычных циклах.

Прямого эквивалента для `break` не существует, но его можно смоделировать — добавить еще одну вложенную лямбду и нелокально вернуться из нее.
```kotlin
fun foo() {
    run loop@{
        listOf(1, 2, 3, 4, 5).forEach {
            if (it == 3) return@loop // нелокальный возврат из лямбды к вызывающему run
            print(it)
        }
    }
    print(" выполнится с использованием вложенной метки")
}
```

При возвращении значения парсер отдаёт предпочтение специализированному возврату.
```kotlin
return@a 1
```

что значит “верни `1` в метке `@a`”, а не “верни выражение с меткой `(@a 1)`”.
